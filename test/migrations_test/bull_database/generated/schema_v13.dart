// dart format width=80
import 'dart:typed_data' as i2;
// GENERATED BY drift_dev, DO NOT MODIFY.
// ignore_for_file: type=lint,unused_import
//
import 'package:drift/drift.dart';

class Transactions extends Table
    with TableInfo<Transactions, TransactionsData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Transactions(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<String> txid = GeneratedColumn<String>(
    'txid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> version = GeneratedColumn<int>(
    'version',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> size = GeneratedColumn<String>(
    'size',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> vsize = GeneratedColumn<String>(
    'vsize',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> locktime = GeneratedColumn<int>(
    'locktime',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> vin = GeneratedColumn<String>(
    'vin',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> vout = GeneratedColumn<String>(
    'vout',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> blockhash = GeneratedColumn<String>(
    'blockhash',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<int> height = GeneratedColumn<int>(
    'height',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<int> confirmations = GeneratedColumn<int>(
    'confirmations',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<int> time = GeneratedColumn<int>(
    'time',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<int> blocktime = GeneratedColumn<int>(
    'blocktime',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  @override
  List<GeneratedColumn> get $columns => [
    txid,
    version,
    size,
    vsize,
    locktime,
    vin,
    vout,
    blockhash,
    height,
    confirmations,
    time,
    blocktime,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'transactions';
  @override
  Set<GeneratedColumn> get $primaryKey => {txid};
  @override
  TransactionsData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TransactionsData(
      txid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}txid'],
      )!,
      version: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}version'],
      )!,
      size: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}size'],
      )!,
      vsize: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}vsize'],
      )!,
      locktime: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}locktime'],
      )!,
      vin: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}vin'],
      )!,
      vout: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}vout'],
      )!,
      blockhash: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}blockhash'],
      ),
      height: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}height'],
      ),
      confirmations: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}confirmations'],
      ),
      time: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}time'],
      ),
      blocktime: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}blocktime'],
      ),
    );
  }

  @override
  Transactions createAlias(String alias) {
    return Transactions(attachedDatabase, alias);
  }

  @override
  List<String> get customConstraints => const ['PRIMARY KEY(txid)'];
  @override
  bool get dontWriteConstraints => true;
}

class TransactionsData extends DataClass
    implements Insertable<TransactionsData> {
  final String txid;
  final int version;
  final String size;
  final String vsize;
  final int locktime;
  final String vin;
  final String vout;
  final String? blockhash;
  final int? height;
  final int? confirmations;
  final int? time;
  final int? blocktime;
  const TransactionsData({
    required this.txid,
    required this.version,
    required this.size,
    required this.vsize,
    required this.locktime,
    required this.vin,
    required this.vout,
    this.blockhash,
    this.height,
    this.confirmations,
    this.time,
    this.blocktime,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['txid'] = Variable<String>(txid);
    map['version'] = Variable<int>(version);
    map['size'] = Variable<String>(size);
    map['vsize'] = Variable<String>(vsize);
    map['locktime'] = Variable<int>(locktime);
    map['vin'] = Variable<String>(vin);
    map['vout'] = Variable<String>(vout);
    if (!nullToAbsent || blockhash != null) {
      map['blockhash'] = Variable<String>(blockhash);
    }
    if (!nullToAbsent || height != null) {
      map['height'] = Variable<int>(height);
    }
    if (!nullToAbsent || confirmations != null) {
      map['confirmations'] = Variable<int>(confirmations);
    }
    if (!nullToAbsent || time != null) {
      map['time'] = Variable<int>(time);
    }
    if (!nullToAbsent || blocktime != null) {
      map['blocktime'] = Variable<int>(blocktime);
    }
    return map;
  }

  TransactionsCompanion toCompanion(bool nullToAbsent) {
    return TransactionsCompanion(
      txid: Value(txid),
      version: Value(version),
      size: Value(size),
      vsize: Value(vsize),
      locktime: Value(locktime),
      vin: Value(vin),
      vout: Value(vout),
      blockhash: blockhash == null && nullToAbsent
          ? const Value.absent()
          : Value(blockhash),
      height: height == null && nullToAbsent
          ? const Value.absent()
          : Value(height),
      confirmations: confirmations == null && nullToAbsent
          ? const Value.absent()
          : Value(confirmations),
      time: time == null && nullToAbsent ? const Value.absent() : Value(time),
      blocktime: blocktime == null && nullToAbsent
          ? const Value.absent()
          : Value(blocktime),
    );
  }

  factory TransactionsData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TransactionsData(
      txid: serializer.fromJson<String>(json['txid']),
      version: serializer.fromJson<int>(json['version']),
      size: serializer.fromJson<String>(json['size']),
      vsize: serializer.fromJson<String>(json['vsize']),
      locktime: serializer.fromJson<int>(json['locktime']),
      vin: serializer.fromJson<String>(json['vin']),
      vout: serializer.fromJson<String>(json['vout']),
      blockhash: serializer.fromJson<String?>(json['blockhash']),
      height: serializer.fromJson<int?>(json['height']),
      confirmations: serializer.fromJson<int?>(json['confirmations']),
      time: serializer.fromJson<int?>(json['time']),
      blocktime: serializer.fromJson<int?>(json['blocktime']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'txid': serializer.toJson<String>(txid),
      'version': serializer.toJson<int>(version),
      'size': serializer.toJson<String>(size),
      'vsize': serializer.toJson<String>(vsize),
      'locktime': serializer.toJson<int>(locktime),
      'vin': serializer.toJson<String>(vin),
      'vout': serializer.toJson<String>(vout),
      'blockhash': serializer.toJson<String?>(blockhash),
      'height': serializer.toJson<int?>(height),
      'confirmations': serializer.toJson<int?>(confirmations),
      'time': serializer.toJson<int?>(time),
      'blocktime': serializer.toJson<int?>(blocktime),
    };
  }

  TransactionsData copyWith({
    String? txid,
    int? version,
    String? size,
    String? vsize,
    int? locktime,
    String? vin,
    String? vout,
    Value<String?> blockhash = const Value.absent(),
    Value<int?> height = const Value.absent(),
    Value<int?> confirmations = const Value.absent(),
    Value<int?> time = const Value.absent(),
    Value<int?> blocktime = const Value.absent(),
  }) => TransactionsData(
    txid: txid ?? this.txid,
    version: version ?? this.version,
    size: size ?? this.size,
    vsize: vsize ?? this.vsize,
    locktime: locktime ?? this.locktime,
    vin: vin ?? this.vin,
    vout: vout ?? this.vout,
    blockhash: blockhash.present ? blockhash.value : this.blockhash,
    height: height.present ? height.value : this.height,
    confirmations: confirmations.present
        ? confirmations.value
        : this.confirmations,
    time: time.present ? time.value : this.time,
    blocktime: blocktime.present ? blocktime.value : this.blocktime,
  );
  TransactionsData copyWithCompanion(TransactionsCompanion data) {
    return TransactionsData(
      txid: data.txid.present ? data.txid.value : this.txid,
      version: data.version.present ? data.version.value : this.version,
      size: data.size.present ? data.size.value : this.size,
      vsize: data.vsize.present ? data.vsize.value : this.vsize,
      locktime: data.locktime.present ? data.locktime.value : this.locktime,
      vin: data.vin.present ? data.vin.value : this.vin,
      vout: data.vout.present ? data.vout.value : this.vout,
      blockhash: data.blockhash.present ? data.blockhash.value : this.blockhash,
      height: data.height.present ? data.height.value : this.height,
      confirmations: data.confirmations.present
          ? data.confirmations.value
          : this.confirmations,
      time: data.time.present ? data.time.value : this.time,
      blocktime: data.blocktime.present ? data.blocktime.value : this.blocktime,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TransactionsData(')
          ..write('txid: $txid, ')
          ..write('version: $version, ')
          ..write('size: $size, ')
          ..write('vsize: $vsize, ')
          ..write('locktime: $locktime, ')
          ..write('vin: $vin, ')
          ..write('vout: $vout, ')
          ..write('blockhash: $blockhash, ')
          ..write('height: $height, ')
          ..write('confirmations: $confirmations, ')
          ..write('time: $time, ')
          ..write('blocktime: $blocktime')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    txid,
    version,
    size,
    vsize,
    locktime,
    vin,
    vout,
    blockhash,
    height,
    confirmations,
    time,
    blocktime,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TransactionsData &&
          other.txid == this.txid &&
          other.version == this.version &&
          other.size == this.size &&
          other.vsize == this.vsize &&
          other.locktime == this.locktime &&
          other.vin == this.vin &&
          other.vout == this.vout &&
          other.blockhash == this.blockhash &&
          other.height == this.height &&
          other.confirmations == this.confirmations &&
          other.time == this.time &&
          other.blocktime == this.blocktime);
}

class TransactionsCompanion extends UpdateCompanion<TransactionsData> {
  final Value<String> txid;
  final Value<int> version;
  final Value<String> size;
  final Value<String> vsize;
  final Value<int> locktime;
  final Value<String> vin;
  final Value<String> vout;
  final Value<String?> blockhash;
  final Value<int?> height;
  final Value<int?> confirmations;
  final Value<int?> time;
  final Value<int?> blocktime;
  final Value<int> rowid;
  const TransactionsCompanion({
    this.txid = const Value.absent(),
    this.version = const Value.absent(),
    this.size = const Value.absent(),
    this.vsize = const Value.absent(),
    this.locktime = const Value.absent(),
    this.vin = const Value.absent(),
    this.vout = const Value.absent(),
    this.blockhash = const Value.absent(),
    this.height = const Value.absent(),
    this.confirmations = const Value.absent(),
    this.time = const Value.absent(),
    this.blocktime = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TransactionsCompanion.insert({
    required String txid,
    required int version,
    required String size,
    required String vsize,
    required int locktime,
    required String vin,
    required String vout,
    this.blockhash = const Value.absent(),
    this.height = const Value.absent(),
    this.confirmations = const Value.absent(),
    this.time = const Value.absent(),
    this.blocktime = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : txid = Value(txid),
       version = Value(version),
       size = Value(size),
       vsize = Value(vsize),
       locktime = Value(locktime),
       vin = Value(vin),
       vout = Value(vout);
  static Insertable<TransactionsData> custom({
    Expression<String>? txid,
    Expression<int>? version,
    Expression<String>? size,
    Expression<String>? vsize,
    Expression<int>? locktime,
    Expression<String>? vin,
    Expression<String>? vout,
    Expression<String>? blockhash,
    Expression<int>? height,
    Expression<int>? confirmations,
    Expression<int>? time,
    Expression<int>? blocktime,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (txid != null) 'txid': txid,
      if (version != null) 'version': version,
      if (size != null) 'size': size,
      if (vsize != null) 'vsize': vsize,
      if (locktime != null) 'locktime': locktime,
      if (vin != null) 'vin': vin,
      if (vout != null) 'vout': vout,
      if (blockhash != null) 'blockhash': blockhash,
      if (height != null) 'height': height,
      if (confirmations != null) 'confirmations': confirmations,
      if (time != null) 'time': time,
      if (blocktime != null) 'blocktime': blocktime,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TransactionsCompanion copyWith({
    Value<String>? txid,
    Value<int>? version,
    Value<String>? size,
    Value<String>? vsize,
    Value<int>? locktime,
    Value<String>? vin,
    Value<String>? vout,
    Value<String?>? blockhash,
    Value<int?>? height,
    Value<int?>? confirmations,
    Value<int?>? time,
    Value<int?>? blocktime,
    Value<int>? rowid,
  }) {
    return TransactionsCompanion(
      txid: txid ?? this.txid,
      version: version ?? this.version,
      size: size ?? this.size,
      vsize: vsize ?? this.vsize,
      locktime: locktime ?? this.locktime,
      vin: vin ?? this.vin,
      vout: vout ?? this.vout,
      blockhash: blockhash ?? this.blockhash,
      height: height ?? this.height,
      confirmations: confirmations ?? this.confirmations,
      time: time ?? this.time,
      blocktime: blocktime ?? this.blocktime,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (txid.present) {
      map['txid'] = Variable<String>(txid.value);
    }
    if (version.present) {
      map['version'] = Variable<int>(version.value);
    }
    if (size.present) {
      map['size'] = Variable<String>(size.value);
    }
    if (vsize.present) {
      map['vsize'] = Variable<String>(vsize.value);
    }
    if (locktime.present) {
      map['locktime'] = Variable<int>(locktime.value);
    }
    if (vin.present) {
      map['vin'] = Variable<String>(vin.value);
    }
    if (vout.present) {
      map['vout'] = Variable<String>(vout.value);
    }
    if (blockhash.present) {
      map['blockhash'] = Variable<String>(blockhash.value);
    }
    if (height.present) {
      map['height'] = Variable<int>(height.value);
    }
    if (confirmations.present) {
      map['confirmations'] = Variable<int>(confirmations.value);
    }
    if (time.present) {
      map['time'] = Variable<int>(time.value);
    }
    if (blocktime.present) {
      map['blocktime'] = Variable<int>(blocktime.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TransactionsCompanion(')
          ..write('txid: $txid, ')
          ..write('version: $version, ')
          ..write('size: $size, ')
          ..write('vsize: $vsize, ')
          ..write('locktime: $locktime, ')
          ..write('vin: $vin, ')
          ..write('vout: $vout, ')
          ..write('blockhash: $blockhash, ')
          ..write('height: $height, ')
          ..write('confirmations: $confirmations, ')
          ..write('time: $time, ')
          ..write('blocktime: $blocktime, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class WalletMetadatas extends Table
    with TableInfo<WalletMetadatas, WalletMetadatasData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  WalletMetadatas(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> masterFingerprint =
      GeneratedColumn<String>(
        'master_fingerprint',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: true,
        $customConstraints: 'NOT NULL',
      );
  late final GeneratedColumn<String> xpubFingerprint = GeneratedColumn<String>(
    'xpub_fingerprint',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> isEncryptedVaultTested = GeneratedColumn<int>(
    'is_encrypted_vault_tested',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_encrypted_vault_tested IN (0, 1))',
  );
  late final GeneratedColumn<int> isPhysicalBackupTested = GeneratedColumn<int>(
    'is_physical_backup_tested',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_physical_backup_tested IN (0, 1))',
  );
  late final GeneratedColumn<int> latestEncryptedBackup = GeneratedColumn<int>(
    'latest_encrypted_backup',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<int> latestPhysicalBackup = GeneratedColumn<int>(
    'latest_physical_backup',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> xpub = GeneratedColumn<String>(
    'xpub',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> externalPublicDescriptor =
      GeneratedColumn<String>(
        'external_public_descriptor',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: true,
        $customConstraints: 'NOT NULL',
      );
  late final GeneratedColumn<String> internalPublicDescriptor =
      GeneratedColumn<String>(
        'internal_public_descriptor',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: true,
        $customConstraints: 'NOT NULL',
      );
  late final GeneratedColumn<String> signer = GeneratedColumn<String>(
    'signer',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> signerDevice = GeneratedColumn<String>(
    'signer_device',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<int> isDefault = GeneratedColumn<int>(
    'is_default',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_default IN (0, 1))',
  );
  late final GeneratedColumn<String> label = GeneratedColumn<String>(
    'label',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> syncedAt = GeneratedColumn<String>(
    'synced_at',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> birthday = GeneratedColumn<String>(
    'birthday',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    masterFingerprint,
    xpubFingerprint,
    isEncryptedVaultTested,
    isPhysicalBackupTested,
    latestEncryptedBackup,
    latestPhysicalBackup,
    xpub,
    externalPublicDescriptor,
    internalPublicDescriptor,
    signer,
    signerDevice,
    isDefault,
    label,
    syncedAt,
    birthday,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'wallet_metadatas';
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  WalletMetadatasData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WalletMetadatasData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      masterFingerprint: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}master_fingerprint'],
      )!,
      xpubFingerprint: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}xpub_fingerprint'],
      )!,
      isEncryptedVaultTested: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_encrypted_vault_tested'],
      )!,
      isPhysicalBackupTested: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_physical_backup_tested'],
      )!,
      latestEncryptedBackup: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}latest_encrypted_backup'],
      ),
      latestPhysicalBackup: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}latest_physical_backup'],
      ),
      xpub: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}xpub'],
      )!,
      externalPublicDescriptor: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}external_public_descriptor'],
      )!,
      internalPublicDescriptor: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}internal_public_descriptor'],
      )!,
      signer: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}signer'],
      )!,
      signerDevice: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}signer_device'],
      ),
      isDefault: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_default'],
      )!,
      label: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}label'],
      ),
      syncedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}synced_at'],
      ),
      birthday: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}birthday'],
      ),
    );
  }

  @override
  WalletMetadatas createAlias(String alias) {
    return WalletMetadatas(attachedDatabase, alias);
  }

  @override
  List<String> get customConstraints => const ['PRIMARY KEY(id)'];
  @override
  bool get dontWriteConstraints => true;
}

class WalletMetadatasData extends DataClass
    implements Insertable<WalletMetadatasData> {
  final String id;
  final String masterFingerprint;
  final String xpubFingerprint;
  final int isEncryptedVaultTested;
  final int isPhysicalBackupTested;
  final int? latestEncryptedBackup;
  final int? latestPhysicalBackup;
  final String xpub;
  final String externalPublicDescriptor;
  final String internalPublicDescriptor;
  final String signer;
  final String? signerDevice;
  final int isDefault;
  final String? label;
  final String? syncedAt;
  final String? birthday;
  const WalletMetadatasData({
    required this.id,
    required this.masterFingerprint,
    required this.xpubFingerprint,
    required this.isEncryptedVaultTested,
    required this.isPhysicalBackupTested,
    this.latestEncryptedBackup,
    this.latestPhysicalBackup,
    required this.xpub,
    required this.externalPublicDescriptor,
    required this.internalPublicDescriptor,
    required this.signer,
    this.signerDevice,
    required this.isDefault,
    this.label,
    this.syncedAt,
    this.birthday,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['master_fingerprint'] = Variable<String>(masterFingerprint);
    map['xpub_fingerprint'] = Variable<String>(xpubFingerprint);
    map['is_encrypted_vault_tested'] = Variable<int>(isEncryptedVaultTested);
    map['is_physical_backup_tested'] = Variable<int>(isPhysicalBackupTested);
    if (!nullToAbsent || latestEncryptedBackup != null) {
      map['latest_encrypted_backup'] = Variable<int>(latestEncryptedBackup);
    }
    if (!nullToAbsent || latestPhysicalBackup != null) {
      map['latest_physical_backup'] = Variable<int>(latestPhysicalBackup);
    }
    map['xpub'] = Variable<String>(xpub);
    map['external_public_descriptor'] = Variable<String>(
      externalPublicDescriptor,
    );
    map['internal_public_descriptor'] = Variable<String>(
      internalPublicDescriptor,
    );
    map['signer'] = Variable<String>(signer);
    if (!nullToAbsent || signerDevice != null) {
      map['signer_device'] = Variable<String>(signerDevice);
    }
    map['is_default'] = Variable<int>(isDefault);
    if (!nullToAbsent || label != null) {
      map['label'] = Variable<String>(label);
    }
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<String>(syncedAt);
    }
    if (!nullToAbsent || birthday != null) {
      map['birthday'] = Variable<String>(birthday);
    }
    return map;
  }

  WalletMetadatasCompanion toCompanion(bool nullToAbsent) {
    return WalletMetadatasCompanion(
      id: Value(id),
      masterFingerprint: Value(masterFingerprint),
      xpubFingerprint: Value(xpubFingerprint),
      isEncryptedVaultTested: Value(isEncryptedVaultTested),
      isPhysicalBackupTested: Value(isPhysicalBackupTested),
      latestEncryptedBackup: latestEncryptedBackup == null && nullToAbsent
          ? const Value.absent()
          : Value(latestEncryptedBackup),
      latestPhysicalBackup: latestPhysicalBackup == null && nullToAbsent
          ? const Value.absent()
          : Value(latestPhysicalBackup),
      xpub: Value(xpub),
      externalPublicDescriptor: Value(externalPublicDescriptor),
      internalPublicDescriptor: Value(internalPublicDescriptor),
      signer: Value(signer),
      signerDevice: signerDevice == null && nullToAbsent
          ? const Value.absent()
          : Value(signerDevice),
      isDefault: Value(isDefault),
      label: label == null && nullToAbsent
          ? const Value.absent()
          : Value(label),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      birthday: birthday == null && nullToAbsent
          ? const Value.absent()
          : Value(birthday),
    );
  }

  factory WalletMetadatasData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return WalletMetadatasData(
      id: serializer.fromJson<String>(json['id']),
      masterFingerprint: serializer.fromJson<String>(json['masterFingerprint']),
      xpubFingerprint: serializer.fromJson<String>(json['xpubFingerprint']),
      isEncryptedVaultTested: serializer.fromJson<int>(
        json['isEncryptedVaultTested'],
      ),
      isPhysicalBackupTested: serializer.fromJson<int>(
        json['isPhysicalBackupTested'],
      ),
      latestEncryptedBackup: serializer.fromJson<int?>(
        json['latestEncryptedBackup'],
      ),
      latestPhysicalBackup: serializer.fromJson<int?>(
        json['latestPhysicalBackup'],
      ),
      xpub: serializer.fromJson<String>(json['xpub']),
      externalPublicDescriptor: serializer.fromJson<String>(
        json['externalPublicDescriptor'],
      ),
      internalPublicDescriptor: serializer.fromJson<String>(
        json['internalPublicDescriptor'],
      ),
      signer: serializer.fromJson<String>(json['signer']),
      signerDevice: serializer.fromJson<String?>(json['signerDevice']),
      isDefault: serializer.fromJson<int>(json['isDefault']),
      label: serializer.fromJson<String?>(json['label']),
      syncedAt: serializer.fromJson<String?>(json['syncedAt']),
      birthday: serializer.fromJson<String?>(json['birthday']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'masterFingerprint': serializer.toJson<String>(masterFingerprint),
      'xpubFingerprint': serializer.toJson<String>(xpubFingerprint),
      'isEncryptedVaultTested': serializer.toJson<int>(isEncryptedVaultTested),
      'isPhysicalBackupTested': serializer.toJson<int>(isPhysicalBackupTested),
      'latestEncryptedBackup': serializer.toJson<int?>(latestEncryptedBackup),
      'latestPhysicalBackup': serializer.toJson<int?>(latestPhysicalBackup),
      'xpub': serializer.toJson<String>(xpub),
      'externalPublicDescriptor': serializer.toJson<String>(
        externalPublicDescriptor,
      ),
      'internalPublicDescriptor': serializer.toJson<String>(
        internalPublicDescriptor,
      ),
      'signer': serializer.toJson<String>(signer),
      'signerDevice': serializer.toJson<String?>(signerDevice),
      'isDefault': serializer.toJson<int>(isDefault),
      'label': serializer.toJson<String?>(label),
      'syncedAt': serializer.toJson<String?>(syncedAt),
      'birthday': serializer.toJson<String?>(birthday),
    };
  }

  WalletMetadatasData copyWith({
    String? id,
    String? masterFingerprint,
    String? xpubFingerprint,
    int? isEncryptedVaultTested,
    int? isPhysicalBackupTested,
    Value<int?> latestEncryptedBackup = const Value.absent(),
    Value<int?> latestPhysicalBackup = const Value.absent(),
    String? xpub,
    String? externalPublicDescriptor,
    String? internalPublicDescriptor,
    String? signer,
    Value<String?> signerDevice = const Value.absent(),
    int? isDefault,
    Value<String?> label = const Value.absent(),
    Value<String?> syncedAt = const Value.absent(),
    Value<String?> birthday = const Value.absent(),
  }) => WalletMetadatasData(
    id: id ?? this.id,
    masterFingerprint: masterFingerprint ?? this.masterFingerprint,
    xpubFingerprint: xpubFingerprint ?? this.xpubFingerprint,
    isEncryptedVaultTested:
        isEncryptedVaultTested ?? this.isEncryptedVaultTested,
    isPhysicalBackupTested:
        isPhysicalBackupTested ?? this.isPhysicalBackupTested,
    latestEncryptedBackup: latestEncryptedBackup.present
        ? latestEncryptedBackup.value
        : this.latestEncryptedBackup,
    latestPhysicalBackup: latestPhysicalBackup.present
        ? latestPhysicalBackup.value
        : this.latestPhysicalBackup,
    xpub: xpub ?? this.xpub,
    externalPublicDescriptor:
        externalPublicDescriptor ?? this.externalPublicDescriptor,
    internalPublicDescriptor:
        internalPublicDescriptor ?? this.internalPublicDescriptor,
    signer: signer ?? this.signer,
    signerDevice: signerDevice.present ? signerDevice.value : this.signerDevice,
    isDefault: isDefault ?? this.isDefault,
    label: label.present ? label.value : this.label,
    syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
    birthday: birthday.present ? birthday.value : this.birthday,
  );
  WalletMetadatasData copyWithCompanion(WalletMetadatasCompanion data) {
    return WalletMetadatasData(
      id: data.id.present ? data.id.value : this.id,
      masterFingerprint: data.masterFingerprint.present
          ? data.masterFingerprint.value
          : this.masterFingerprint,
      xpubFingerprint: data.xpubFingerprint.present
          ? data.xpubFingerprint.value
          : this.xpubFingerprint,
      isEncryptedVaultTested: data.isEncryptedVaultTested.present
          ? data.isEncryptedVaultTested.value
          : this.isEncryptedVaultTested,
      isPhysicalBackupTested: data.isPhysicalBackupTested.present
          ? data.isPhysicalBackupTested.value
          : this.isPhysicalBackupTested,
      latestEncryptedBackup: data.latestEncryptedBackup.present
          ? data.latestEncryptedBackup.value
          : this.latestEncryptedBackup,
      latestPhysicalBackup: data.latestPhysicalBackup.present
          ? data.latestPhysicalBackup.value
          : this.latestPhysicalBackup,
      xpub: data.xpub.present ? data.xpub.value : this.xpub,
      externalPublicDescriptor: data.externalPublicDescriptor.present
          ? data.externalPublicDescriptor.value
          : this.externalPublicDescriptor,
      internalPublicDescriptor: data.internalPublicDescriptor.present
          ? data.internalPublicDescriptor.value
          : this.internalPublicDescriptor,
      signer: data.signer.present ? data.signer.value : this.signer,
      signerDevice: data.signerDevice.present
          ? data.signerDevice.value
          : this.signerDevice,
      isDefault: data.isDefault.present ? data.isDefault.value : this.isDefault,
      label: data.label.present ? data.label.value : this.label,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      birthday: data.birthday.present ? data.birthday.value : this.birthday,
    );
  }

  @override
  String toString() {
    return (StringBuffer('WalletMetadatasData(')
          ..write('id: $id, ')
          ..write('masterFingerprint: $masterFingerprint, ')
          ..write('xpubFingerprint: $xpubFingerprint, ')
          ..write('isEncryptedVaultTested: $isEncryptedVaultTested, ')
          ..write('isPhysicalBackupTested: $isPhysicalBackupTested, ')
          ..write('latestEncryptedBackup: $latestEncryptedBackup, ')
          ..write('latestPhysicalBackup: $latestPhysicalBackup, ')
          ..write('xpub: $xpub, ')
          ..write('externalPublicDescriptor: $externalPublicDescriptor, ')
          ..write('internalPublicDescriptor: $internalPublicDescriptor, ')
          ..write('signer: $signer, ')
          ..write('signerDevice: $signerDevice, ')
          ..write('isDefault: $isDefault, ')
          ..write('label: $label, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('birthday: $birthday')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    masterFingerprint,
    xpubFingerprint,
    isEncryptedVaultTested,
    isPhysicalBackupTested,
    latestEncryptedBackup,
    latestPhysicalBackup,
    xpub,
    externalPublicDescriptor,
    internalPublicDescriptor,
    signer,
    signerDevice,
    isDefault,
    label,
    syncedAt,
    birthday,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WalletMetadatasData &&
          other.id == this.id &&
          other.masterFingerprint == this.masterFingerprint &&
          other.xpubFingerprint == this.xpubFingerprint &&
          other.isEncryptedVaultTested == this.isEncryptedVaultTested &&
          other.isPhysicalBackupTested == this.isPhysicalBackupTested &&
          other.latestEncryptedBackup == this.latestEncryptedBackup &&
          other.latestPhysicalBackup == this.latestPhysicalBackup &&
          other.xpub == this.xpub &&
          other.externalPublicDescriptor == this.externalPublicDescriptor &&
          other.internalPublicDescriptor == this.internalPublicDescriptor &&
          other.signer == this.signer &&
          other.signerDevice == this.signerDevice &&
          other.isDefault == this.isDefault &&
          other.label == this.label &&
          other.syncedAt == this.syncedAt &&
          other.birthday == this.birthday);
}

class WalletMetadatasCompanion extends UpdateCompanion<WalletMetadatasData> {
  final Value<String> id;
  final Value<String> masterFingerprint;
  final Value<String> xpubFingerprint;
  final Value<int> isEncryptedVaultTested;
  final Value<int> isPhysicalBackupTested;
  final Value<int?> latestEncryptedBackup;
  final Value<int?> latestPhysicalBackup;
  final Value<String> xpub;
  final Value<String> externalPublicDescriptor;
  final Value<String> internalPublicDescriptor;
  final Value<String> signer;
  final Value<String?> signerDevice;
  final Value<int> isDefault;
  final Value<String?> label;
  final Value<String?> syncedAt;
  final Value<String?> birthday;
  final Value<int> rowid;
  const WalletMetadatasCompanion({
    this.id = const Value.absent(),
    this.masterFingerprint = const Value.absent(),
    this.xpubFingerprint = const Value.absent(),
    this.isEncryptedVaultTested = const Value.absent(),
    this.isPhysicalBackupTested = const Value.absent(),
    this.latestEncryptedBackup = const Value.absent(),
    this.latestPhysicalBackup = const Value.absent(),
    this.xpub = const Value.absent(),
    this.externalPublicDescriptor = const Value.absent(),
    this.internalPublicDescriptor = const Value.absent(),
    this.signer = const Value.absent(),
    this.signerDevice = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.label = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.birthday = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  WalletMetadatasCompanion.insert({
    required String id,
    required String masterFingerprint,
    required String xpubFingerprint,
    required int isEncryptedVaultTested,
    required int isPhysicalBackupTested,
    this.latestEncryptedBackup = const Value.absent(),
    this.latestPhysicalBackup = const Value.absent(),
    required String xpub,
    required String externalPublicDescriptor,
    required String internalPublicDescriptor,
    required String signer,
    this.signerDevice = const Value.absent(),
    required int isDefault,
    this.label = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.birthday = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       masterFingerprint = Value(masterFingerprint),
       xpubFingerprint = Value(xpubFingerprint),
       isEncryptedVaultTested = Value(isEncryptedVaultTested),
       isPhysicalBackupTested = Value(isPhysicalBackupTested),
       xpub = Value(xpub),
       externalPublicDescriptor = Value(externalPublicDescriptor),
       internalPublicDescriptor = Value(internalPublicDescriptor),
       signer = Value(signer),
       isDefault = Value(isDefault);
  static Insertable<WalletMetadatasData> custom({
    Expression<String>? id,
    Expression<String>? masterFingerprint,
    Expression<String>? xpubFingerprint,
    Expression<int>? isEncryptedVaultTested,
    Expression<int>? isPhysicalBackupTested,
    Expression<int>? latestEncryptedBackup,
    Expression<int>? latestPhysicalBackup,
    Expression<String>? xpub,
    Expression<String>? externalPublicDescriptor,
    Expression<String>? internalPublicDescriptor,
    Expression<String>? signer,
    Expression<String>? signerDevice,
    Expression<int>? isDefault,
    Expression<String>? label,
    Expression<String>? syncedAt,
    Expression<String>? birthday,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (masterFingerprint != null) 'master_fingerprint': masterFingerprint,
      if (xpubFingerprint != null) 'xpub_fingerprint': xpubFingerprint,
      if (isEncryptedVaultTested != null)
        'is_encrypted_vault_tested': isEncryptedVaultTested,
      if (isPhysicalBackupTested != null)
        'is_physical_backup_tested': isPhysicalBackupTested,
      if (latestEncryptedBackup != null)
        'latest_encrypted_backup': latestEncryptedBackup,
      if (latestPhysicalBackup != null)
        'latest_physical_backup': latestPhysicalBackup,
      if (xpub != null) 'xpub': xpub,
      if (externalPublicDescriptor != null)
        'external_public_descriptor': externalPublicDescriptor,
      if (internalPublicDescriptor != null)
        'internal_public_descriptor': internalPublicDescriptor,
      if (signer != null) 'signer': signer,
      if (signerDevice != null) 'signer_device': signerDevice,
      if (isDefault != null) 'is_default': isDefault,
      if (label != null) 'label': label,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (birthday != null) 'birthday': birthday,
      if (rowid != null) 'rowid': rowid,
    });
  }

  WalletMetadatasCompanion copyWith({
    Value<String>? id,
    Value<String>? masterFingerprint,
    Value<String>? xpubFingerprint,
    Value<int>? isEncryptedVaultTested,
    Value<int>? isPhysicalBackupTested,
    Value<int?>? latestEncryptedBackup,
    Value<int?>? latestPhysicalBackup,
    Value<String>? xpub,
    Value<String>? externalPublicDescriptor,
    Value<String>? internalPublicDescriptor,
    Value<String>? signer,
    Value<String?>? signerDevice,
    Value<int>? isDefault,
    Value<String?>? label,
    Value<String?>? syncedAt,
    Value<String?>? birthday,
    Value<int>? rowid,
  }) {
    return WalletMetadatasCompanion(
      id: id ?? this.id,
      masterFingerprint: masterFingerprint ?? this.masterFingerprint,
      xpubFingerprint: xpubFingerprint ?? this.xpubFingerprint,
      isEncryptedVaultTested:
          isEncryptedVaultTested ?? this.isEncryptedVaultTested,
      isPhysicalBackupTested:
          isPhysicalBackupTested ?? this.isPhysicalBackupTested,
      latestEncryptedBackup:
          latestEncryptedBackup ?? this.latestEncryptedBackup,
      latestPhysicalBackup: latestPhysicalBackup ?? this.latestPhysicalBackup,
      xpub: xpub ?? this.xpub,
      externalPublicDescriptor:
          externalPublicDescriptor ?? this.externalPublicDescriptor,
      internalPublicDescriptor:
          internalPublicDescriptor ?? this.internalPublicDescriptor,
      signer: signer ?? this.signer,
      signerDevice: signerDevice ?? this.signerDevice,
      isDefault: isDefault ?? this.isDefault,
      label: label ?? this.label,
      syncedAt: syncedAt ?? this.syncedAt,
      birthday: birthday ?? this.birthday,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (masterFingerprint.present) {
      map['master_fingerprint'] = Variable<String>(masterFingerprint.value);
    }
    if (xpubFingerprint.present) {
      map['xpub_fingerprint'] = Variable<String>(xpubFingerprint.value);
    }
    if (isEncryptedVaultTested.present) {
      map['is_encrypted_vault_tested'] = Variable<int>(
        isEncryptedVaultTested.value,
      );
    }
    if (isPhysicalBackupTested.present) {
      map['is_physical_backup_tested'] = Variable<int>(
        isPhysicalBackupTested.value,
      );
    }
    if (latestEncryptedBackup.present) {
      map['latest_encrypted_backup'] = Variable<int>(
        latestEncryptedBackup.value,
      );
    }
    if (latestPhysicalBackup.present) {
      map['latest_physical_backup'] = Variable<int>(latestPhysicalBackup.value);
    }
    if (xpub.present) {
      map['xpub'] = Variable<String>(xpub.value);
    }
    if (externalPublicDescriptor.present) {
      map['external_public_descriptor'] = Variable<String>(
        externalPublicDescriptor.value,
      );
    }
    if (internalPublicDescriptor.present) {
      map['internal_public_descriptor'] = Variable<String>(
        internalPublicDescriptor.value,
      );
    }
    if (signer.present) {
      map['signer'] = Variable<String>(signer.value);
    }
    if (signerDevice.present) {
      map['signer_device'] = Variable<String>(signerDevice.value);
    }
    if (isDefault.present) {
      map['is_default'] = Variable<int>(isDefault.value);
    }
    if (label.present) {
      map['label'] = Variable<String>(label.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<String>(syncedAt.value);
    }
    if (birthday.present) {
      map['birthday'] = Variable<String>(birthday.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WalletMetadatasCompanion(')
          ..write('id: $id, ')
          ..write('masterFingerprint: $masterFingerprint, ')
          ..write('xpubFingerprint: $xpubFingerprint, ')
          ..write('isEncryptedVaultTested: $isEncryptedVaultTested, ')
          ..write('isPhysicalBackupTested: $isPhysicalBackupTested, ')
          ..write('latestEncryptedBackup: $latestEncryptedBackup, ')
          ..write('latestPhysicalBackup: $latestPhysicalBackup, ')
          ..write('xpub: $xpub, ')
          ..write('externalPublicDescriptor: $externalPublicDescriptor, ')
          ..write('internalPublicDescriptor: $internalPublicDescriptor, ')
          ..write('signer: $signer, ')
          ..write('signerDevice: $signerDevice, ')
          ..write('isDefault: $isDefault, ')
          ..write('label: $label, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('birthday: $birthday, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class Labels extends Table with TableInfo<Labels, LabelsData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Labels(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT',
  );
  late final GeneratedColumn<String> label = GeneratedColumn<String>(
    'label',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> reference = GeneratedColumn<String>(
    'reference',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> origin = GeneratedColumn<String>(
    'origin',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  @override
  List<GeneratedColumn> get $columns => [id, label, reference, type, origin];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'labels';
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {label, reference},
  ];
  @override
  LabelsData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LabelsData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      label: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}label'],
      )!,
      reference: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reference'],
      )!,
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      )!,
      origin: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}origin'],
      ),
    );
  }

  @override
  Labels createAlias(String alias) {
    return Labels(attachedDatabase, alias);
  }

  @override
  List<String> get customConstraints => const ['UNIQUE(label, reference)'];
  @override
  bool get dontWriteConstraints => true;
}

class LabelsData extends DataClass implements Insertable<LabelsData> {
  final int id;
  final String label;
  final String reference;
  final String type;
  final String? origin;
  const LabelsData({
    required this.id,
    required this.label,
    required this.reference,
    required this.type,
    this.origin,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['label'] = Variable<String>(label);
    map['reference'] = Variable<String>(reference);
    map['type'] = Variable<String>(type);
    if (!nullToAbsent || origin != null) {
      map['origin'] = Variable<String>(origin);
    }
    return map;
  }

  LabelsCompanion toCompanion(bool nullToAbsent) {
    return LabelsCompanion(
      id: Value(id),
      label: Value(label),
      reference: Value(reference),
      type: Value(type),
      origin: origin == null && nullToAbsent
          ? const Value.absent()
          : Value(origin),
    );
  }

  factory LabelsData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LabelsData(
      id: serializer.fromJson<int>(json['id']),
      label: serializer.fromJson<String>(json['label']),
      reference: serializer.fromJson<String>(json['reference']),
      type: serializer.fromJson<String>(json['type']),
      origin: serializer.fromJson<String?>(json['origin']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'label': serializer.toJson<String>(label),
      'reference': serializer.toJson<String>(reference),
      'type': serializer.toJson<String>(type),
      'origin': serializer.toJson<String?>(origin),
    };
  }

  LabelsData copyWith({
    int? id,
    String? label,
    String? reference,
    String? type,
    Value<String?> origin = const Value.absent(),
  }) => LabelsData(
    id: id ?? this.id,
    label: label ?? this.label,
    reference: reference ?? this.reference,
    type: type ?? this.type,
    origin: origin.present ? origin.value : this.origin,
  );
  LabelsData copyWithCompanion(LabelsCompanion data) {
    return LabelsData(
      id: data.id.present ? data.id.value : this.id,
      label: data.label.present ? data.label.value : this.label,
      reference: data.reference.present ? data.reference.value : this.reference,
      type: data.type.present ? data.type.value : this.type,
      origin: data.origin.present ? data.origin.value : this.origin,
    );
  }

  @override
  String toString() {
    return (StringBuffer('LabelsData(')
          ..write('id: $id, ')
          ..write('label: $label, ')
          ..write('reference: $reference, ')
          ..write('type: $type, ')
          ..write('origin: $origin')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, label, reference, type, origin);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LabelsData &&
          other.id == this.id &&
          other.label == this.label &&
          other.reference == this.reference &&
          other.type == this.type &&
          other.origin == this.origin);
}

class LabelsCompanion extends UpdateCompanion<LabelsData> {
  final Value<int> id;
  final Value<String> label;
  final Value<String> reference;
  final Value<String> type;
  final Value<String?> origin;
  const LabelsCompanion({
    this.id = const Value.absent(),
    this.label = const Value.absent(),
    this.reference = const Value.absent(),
    this.type = const Value.absent(),
    this.origin = const Value.absent(),
  });
  LabelsCompanion.insert({
    this.id = const Value.absent(),
    required String label,
    required String reference,
    required String type,
    this.origin = const Value.absent(),
  }) : label = Value(label),
       reference = Value(reference),
       type = Value(type);
  static Insertable<LabelsData> custom({
    Expression<int>? id,
    Expression<String>? label,
    Expression<String>? reference,
    Expression<String>? type,
    Expression<String>? origin,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (label != null) 'label': label,
      if (reference != null) 'reference': reference,
      if (type != null) 'type': type,
      if (origin != null) 'origin': origin,
    });
  }

  LabelsCompanion copyWith({
    Value<int>? id,
    Value<String>? label,
    Value<String>? reference,
    Value<String>? type,
    Value<String?>? origin,
  }) {
    return LabelsCompanion(
      id: id ?? this.id,
      label: label ?? this.label,
      reference: reference ?? this.reference,
      type: type ?? this.type,
      origin: origin ?? this.origin,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (label.present) {
      map['label'] = Variable<String>(label.value);
    }
    if (reference.present) {
      map['reference'] = Variable<String>(reference.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (origin.present) {
      map['origin'] = Variable<String>(origin.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LabelsCompanion(')
          ..write('id: $id, ')
          ..write('label: $label, ')
          ..write('reference: $reference, ')
          ..write('type: $type, ')
          ..write('origin: $origin')
          ..write(')'))
        .toString();
  }
}

class Settings extends Table with TableInfo<Settings, SettingsData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Settings(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT',
  );
  late final GeneratedColumn<String> environment = GeneratedColumn<String>(
    'environment',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> bitcoinUnit = GeneratedColumn<String>(
    'bitcoin_unit',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> language = GeneratedColumn<String>(
    'language',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> currency = GeneratedColumn<String>(
    'currency',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> hideAmounts = GeneratedColumn<int>(
    'hide_amounts',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (hide_amounts IN (0, 1))',
  );
  late final GeneratedColumn<int> isSuperuser = GeneratedColumn<int>(
    'is_superuser',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_superuser IN (0, 1))',
  );
  late final GeneratedColumn<int> isDevModeEnabled = GeneratedColumn<int>(
    'is_dev_mode_enabled',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints:
        'NOT NULL DEFAULT 0 CHECK (is_dev_mode_enabled IN (0, 1))',
    defaultValue: const CustomExpression('0'),
  );
  late final GeneratedColumn<int> useTorProxy = GeneratedColumn<int>(
    'use_tor_proxy',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL DEFAULT 0 CHECK (use_tor_proxy IN (0, 1))',
    defaultValue: const CustomExpression('0'),
  );
  late final GeneratedColumn<int> torProxyPort = GeneratedColumn<int>(
    'tor_proxy_port',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL DEFAULT 9050',
    defaultValue: const CustomExpression('9050'),
  );
  late final GeneratedColumn<String> themeMode = GeneratedColumn<String>(
    'theme_mode',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL DEFAULT \'system\'',
    defaultValue: const CustomExpression('\'system\''),
  );
  late final GeneratedColumn<int> isErrorReportingEnabled =
      GeneratedColumn<int>(
        'is_error_reporting_enabled',
        aliasedName,
        false,
        type: DriftSqlType.int,
        requiredDuringInsert: false,
        $customConstraints:
            'NOT NULL DEFAULT 0 CHECK (is_error_reporting_enabled IN (0, 1))',
        defaultValue: const CustomExpression('0'),
      );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    environment,
    bitcoinUnit,
    language,
    currency,
    hideAmounts,
    isSuperuser,
    isDevModeEnabled,
    useTorProxy,
    torProxyPort,
    themeMode,
    isErrorReportingEnabled,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'settings';
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SettingsData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SettingsData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      environment: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}environment'],
      )!,
      bitcoinUnit: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bitcoin_unit'],
      )!,
      language: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}language'],
      )!,
      currency: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}currency'],
      )!,
      hideAmounts: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}hide_amounts'],
      )!,
      isSuperuser: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_superuser'],
      )!,
      isDevModeEnabled: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_dev_mode_enabled'],
      )!,
      useTorProxy: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}use_tor_proxy'],
      )!,
      torProxyPort: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}tor_proxy_port'],
      )!,
      themeMode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}theme_mode'],
      )!,
      isErrorReportingEnabled: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_error_reporting_enabled'],
      )!,
    );
  }

  @override
  Settings createAlias(String alias) {
    return Settings(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class SettingsData extends DataClass implements Insertable<SettingsData> {
  final int id;
  final String environment;
  final String bitcoinUnit;
  final String language;
  final String currency;
  final int hideAmounts;
  final int isSuperuser;
  final int isDevModeEnabled;
  final int useTorProxy;
  final int torProxyPort;
  final String themeMode;
  final int isErrorReportingEnabled;
  const SettingsData({
    required this.id,
    required this.environment,
    required this.bitcoinUnit,
    required this.language,
    required this.currency,
    required this.hideAmounts,
    required this.isSuperuser,
    required this.isDevModeEnabled,
    required this.useTorProxy,
    required this.torProxyPort,
    required this.themeMode,
    required this.isErrorReportingEnabled,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['environment'] = Variable<String>(environment);
    map['bitcoin_unit'] = Variable<String>(bitcoinUnit);
    map['language'] = Variable<String>(language);
    map['currency'] = Variable<String>(currency);
    map['hide_amounts'] = Variable<int>(hideAmounts);
    map['is_superuser'] = Variable<int>(isSuperuser);
    map['is_dev_mode_enabled'] = Variable<int>(isDevModeEnabled);
    map['use_tor_proxy'] = Variable<int>(useTorProxy);
    map['tor_proxy_port'] = Variable<int>(torProxyPort);
    map['theme_mode'] = Variable<String>(themeMode);
    map['is_error_reporting_enabled'] = Variable<int>(isErrorReportingEnabled);
    return map;
  }

  SettingsCompanion toCompanion(bool nullToAbsent) {
    return SettingsCompanion(
      id: Value(id),
      environment: Value(environment),
      bitcoinUnit: Value(bitcoinUnit),
      language: Value(language),
      currency: Value(currency),
      hideAmounts: Value(hideAmounts),
      isSuperuser: Value(isSuperuser),
      isDevModeEnabled: Value(isDevModeEnabled),
      useTorProxy: Value(useTorProxy),
      torProxyPort: Value(torProxyPort),
      themeMode: Value(themeMode),
      isErrorReportingEnabled: Value(isErrorReportingEnabled),
    );
  }

  factory SettingsData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SettingsData(
      id: serializer.fromJson<int>(json['id']),
      environment: serializer.fromJson<String>(json['environment']),
      bitcoinUnit: serializer.fromJson<String>(json['bitcoinUnit']),
      language: serializer.fromJson<String>(json['language']),
      currency: serializer.fromJson<String>(json['currency']),
      hideAmounts: serializer.fromJson<int>(json['hideAmounts']),
      isSuperuser: serializer.fromJson<int>(json['isSuperuser']),
      isDevModeEnabled: serializer.fromJson<int>(json['isDevModeEnabled']),
      useTorProxy: serializer.fromJson<int>(json['useTorProxy']),
      torProxyPort: serializer.fromJson<int>(json['torProxyPort']),
      themeMode: serializer.fromJson<String>(json['themeMode']),
      isErrorReportingEnabled: serializer.fromJson<int>(
        json['isErrorReportingEnabled'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'environment': serializer.toJson<String>(environment),
      'bitcoinUnit': serializer.toJson<String>(bitcoinUnit),
      'language': serializer.toJson<String>(language),
      'currency': serializer.toJson<String>(currency),
      'hideAmounts': serializer.toJson<int>(hideAmounts),
      'isSuperuser': serializer.toJson<int>(isSuperuser),
      'isDevModeEnabled': serializer.toJson<int>(isDevModeEnabled),
      'useTorProxy': serializer.toJson<int>(useTorProxy),
      'torProxyPort': serializer.toJson<int>(torProxyPort),
      'themeMode': serializer.toJson<String>(themeMode),
      'isErrorReportingEnabled': serializer.toJson<int>(
        isErrorReportingEnabled,
      ),
    };
  }

  SettingsData copyWith({
    int? id,
    String? environment,
    String? bitcoinUnit,
    String? language,
    String? currency,
    int? hideAmounts,
    int? isSuperuser,
    int? isDevModeEnabled,
    int? useTorProxy,
    int? torProxyPort,
    String? themeMode,
    int? isErrorReportingEnabled,
  }) => SettingsData(
    id: id ?? this.id,
    environment: environment ?? this.environment,
    bitcoinUnit: bitcoinUnit ?? this.bitcoinUnit,
    language: language ?? this.language,
    currency: currency ?? this.currency,
    hideAmounts: hideAmounts ?? this.hideAmounts,
    isSuperuser: isSuperuser ?? this.isSuperuser,
    isDevModeEnabled: isDevModeEnabled ?? this.isDevModeEnabled,
    useTorProxy: useTorProxy ?? this.useTorProxy,
    torProxyPort: torProxyPort ?? this.torProxyPort,
    themeMode: themeMode ?? this.themeMode,
    isErrorReportingEnabled:
        isErrorReportingEnabled ?? this.isErrorReportingEnabled,
  );
  SettingsData copyWithCompanion(SettingsCompanion data) {
    return SettingsData(
      id: data.id.present ? data.id.value : this.id,
      environment: data.environment.present
          ? data.environment.value
          : this.environment,
      bitcoinUnit: data.bitcoinUnit.present
          ? data.bitcoinUnit.value
          : this.bitcoinUnit,
      language: data.language.present ? data.language.value : this.language,
      currency: data.currency.present ? data.currency.value : this.currency,
      hideAmounts: data.hideAmounts.present
          ? data.hideAmounts.value
          : this.hideAmounts,
      isSuperuser: data.isSuperuser.present
          ? data.isSuperuser.value
          : this.isSuperuser,
      isDevModeEnabled: data.isDevModeEnabled.present
          ? data.isDevModeEnabled.value
          : this.isDevModeEnabled,
      useTorProxy: data.useTorProxy.present
          ? data.useTorProxy.value
          : this.useTorProxy,
      torProxyPort: data.torProxyPort.present
          ? data.torProxyPort.value
          : this.torProxyPort,
      themeMode: data.themeMode.present ? data.themeMode.value : this.themeMode,
      isErrorReportingEnabled: data.isErrorReportingEnabled.present
          ? data.isErrorReportingEnabled.value
          : this.isErrorReportingEnabled,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SettingsData(')
          ..write('id: $id, ')
          ..write('environment: $environment, ')
          ..write('bitcoinUnit: $bitcoinUnit, ')
          ..write('language: $language, ')
          ..write('currency: $currency, ')
          ..write('hideAmounts: $hideAmounts, ')
          ..write('isSuperuser: $isSuperuser, ')
          ..write('isDevModeEnabled: $isDevModeEnabled, ')
          ..write('useTorProxy: $useTorProxy, ')
          ..write('torProxyPort: $torProxyPort, ')
          ..write('themeMode: $themeMode, ')
          ..write('isErrorReportingEnabled: $isErrorReportingEnabled')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    environment,
    bitcoinUnit,
    language,
    currency,
    hideAmounts,
    isSuperuser,
    isDevModeEnabled,
    useTorProxy,
    torProxyPort,
    themeMode,
    isErrorReportingEnabled,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SettingsData &&
          other.id == this.id &&
          other.environment == this.environment &&
          other.bitcoinUnit == this.bitcoinUnit &&
          other.language == this.language &&
          other.currency == this.currency &&
          other.hideAmounts == this.hideAmounts &&
          other.isSuperuser == this.isSuperuser &&
          other.isDevModeEnabled == this.isDevModeEnabled &&
          other.useTorProxy == this.useTorProxy &&
          other.torProxyPort == this.torProxyPort &&
          other.themeMode == this.themeMode &&
          other.isErrorReportingEnabled == this.isErrorReportingEnabled);
}

class SettingsCompanion extends UpdateCompanion<SettingsData> {
  final Value<int> id;
  final Value<String> environment;
  final Value<String> bitcoinUnit;
  final Value<String> language;
  final Value<String> currency;
  final Value<int> hideAmounts;
  final Value<int> isSuperuser;
  final Value<int> isDevModeEnabled;
  final Value<int> useTorProxy;
  final Value<int> torProxyPort;
  final Value<String> themeMode;
  final Value<int> isErrorReportingEnabled;
  const SettingsCompanion({
    this.id = const Value.absent(),
    this.environment = const Value.absent(),
    this.bitcoinUnit = const Value.absent(),
    this.language = const Value.absent(),
    this.currency = const Value.absent(),
    this.hideAmounts = const Value.absent(),
    this.isSuperuser = const Value.absent(),
    this.isDevModeEnabled = const Value.absent(),
    this.useTorProxy = const Value.absent(),
    this.torProxyPort = const Value.absent(),
    this.themeMode = const Value.absent(),
    this.isErrorReportingEnabled = const Value.absent(),
  });
  SettingsCompanion.insert({
    this.id = const Value.absent(),
    required String environment,
    required String bitcoinUnit,
    required String language,
    required String currency,
    required int hideAmounts,
    required int isSuperuser,
    this.isDevModeEnabled = const Value.absent(),
    this.useTorProxy = const Value.absent(),
    this.torProxyPort = const Value.absent(),
    this.themeMode = const Value.absent(),
    this.isErrorReportingEnabled = const Value.absent(),
  }) : environment = Value(environment),
       bitcoinUnit = Value(bitcoinUnit),
       language = Value(language),
       currency = Value(currency),
       hideAmounts = Value(hideAmounts),
       isSuperuser = Value(isSuperuser);
  static Insertable<SettingsData> custom({
    Expression<int>? id,
    Expression<String>? environment,
    Expression<String>? bitcoinUnit,
    Expression<String>? language,
    Expression<String>? currency,
    Expression<int>? hideAmounts,
    Expression<int>? isSuperuser,
    Expression<int>? isDevModeEnabled,
    Expression<int>? useTorProxy,
    Expression<int>? torProxyPort,
    Expression<String>? themeMode,
    Expression<int>? isErrorReportingEnabled,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (environment != null) 'environment': environment,
      if (bitcoinUnit != null) 'bitcoin_unit': bitcoinUnit,
      if (language != null) 'language': language,
      if (currency != null) 'currency': currency,
      if (hideAmounts != null) 'hide_amounts': hideAmounts,
      if (isSuperuser != null) 'is_superuser': isSuperuser,
      if (isDevModeEnabled != null) 'is_dev_mode_enabled': isDevModeEnabled,
      if (useTorProxy != null) 'use_tor_proxy': useTorProxy,
      if (torProxyPort != null) 'tor_proxy_port': torProxyPort,
      if (themeMode != null) 'theme_mode': themeMode,
      if (isErrorReportingEnabled != null)
        'is_error_reporting_enabled': isErrorReportingEnabled,
    });
  }

  SettingsCompanion copyWith({
    Value<int>? id,
    Value<String>? environment,
    Value<String>? bitcoinUnit,
    Value<String>? language,
    Value<String>? currency,
    Value<int>? hideAmounts,
    Value<int>? isSuperuser,
    Value<int>? isDevModeEnabled,
    Value<int>? useTorProxy,
    Value<int>? torProxyPort,
    Value<String>? themeMode,
    Value<int>? isErrorReportingEnabled,
  }) {
    return SettingsCompanion(
      id: id ?? this.id,
      environment: environment ?? this.environment,
      bitcoinUnit: bitcoinUnit ?? this.bitcoinUnit,
      language: language ?? this.language,
      currency: currency ?? this.currency,
      hideAmounts: hideAmounts ?? this.hideAmounts,
      isSuperuser: isSuperuser ?? this.isSuperuser,
      isDevModeEnabled: isDevModeEnabled ?? this.isDevModeEnabled,
      useTorProxy: useTorProxy ?? this.useTorProxy,
      torProxyPort: torProxyPort ?? this.torProxyPort,
      themeMode: themeMode ?? this.themeMode,
      isErrorReportingEnabled:
          isErrorReportingEnabled ?? this.isErrorReportingEnabled,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (environment.present) {
      map['environment'] = Variable<String>(environment.value);
    }
    if (bitcoinUnit.present) {
      map['bitcoin_unit'] = Variable<String>(bitcoinUnit.value);
    }
    if (language.present) {
      map['language'] = Variable<String>(language.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (hideAmounts.present) {
      map['hide_amounts'] = Variable<int>(hideAmounts.value);
    }
    if (isSuperuser.present) {
      map['is_superuser'] = Variable<int>(isSuperuser.value);
    }
    if (isDevModeEnabled.present) {
      map['is_dev_mode_enabled'] = Variable<int>(isDevModeEnabled.value);
    }
    if (useTorProxy.present) {
      map['use_tor_proxy'] = Variable<int>(useTorProxy.value);
    }
    if (torProxyPort.present) {
      map['tor_proxy_port'] = Variable<int>(torProxyPort.value);
    }
    if (themeMode.present) {
      map['theme_mode'] = Variable<String>(themeMode.value);
    }
    if (isErrorReportingEnabled.present) {
      map['is_error_reporting_enabled'] = Variable<int>(
        isErrorReportingEnabled.value,
      );
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SettingsCompanion(')
          ..write('id: $id, ')
          ..write('environment: $environment, ')
          ..write('bitcoinUnit: $bitcoinUnit, ')
          ..write('language: $language, ')
          ..write('currency: $currency, ')
          ..write('hideAmounts: $hideAmounts, ')
          ..write('isSuperuser: $isSuperuser, ')
          ..write('isDevModeEnabled: $isDevModeEnabled, ')
          ..write('useTorProxy: $useTorProxy, ')
          ..write('torProxyPort: $torProxyPort, ')
          ..write('themeMode: $themeMode, ')
          ..write('isErrorReportingEnabled: $isErrorReportingEnabled')
          ..write(')'))
        .toString();
  }
}

class AppSettings extends Table with TableInfo<AppSettings, AppSettingsData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AppSettings(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT',
  );
  late final GeneratedColumn<String> fiatCurrencyCode = GeneratedColumn<String>(
    'fiat_currency_code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL DEFAULT \'CAD\'',
    defaultValue: const CustomExpression('\'CAD\''),
  );
  late final GeneratedColumn<String> bitcoinUnit = GeneratedColumn<String>(
    'bitcoin_unit',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL DEFAULT \'btc\'',
    defaultValue: const CustomExpression('\'btc\''),
  );
  late final GeneratedColumn<String> languageTag = GeneratedColumn<String>(
    'language_tag',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL DEFAULT \'en-US\'',
    defaultValue: const CustomExpression('\'en-US\''),
  );
  late final GeneratedColumn<String> themeMode = GeneratedColumn<String>(
    'theme_mode',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL DEFAULT \'system\'',
    defaultValue: const CustomExpression('\'system\''),
  );
  late final GeneratedColumn<int> hideAmounts = GeneratedColumn<int>(
    'hide_amounts',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL DEFAULT 0 CHECK (hide_amounts IN (0, 1))',
    defaultValue: const CustomExpression('0'),
  );
  late final GeneratedColumn<String> environmentMode = GeneratedColumn<String>(
    'environment_mode',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL DEFAULT \'production\'',
    defaultValue: const CustomExpression('\'production\''),
  );
  late final GeneratedColumn<int> superuserModeEnabled = GeneratedColumn<int>(
    'superuser_mode_enabled',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints:
        'NOT NULL DEFAULT 0 CHECK (superuser_mode_enabled IN (0, 1))',
    defaultValue: const CustomExpression('0'),
  );
  late final GeneratedColumn<String> featureLevel = GeneratedColumn<String>(
    'feature_level',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL DEFAULT \'stable\'',
    defaultValue: const CustomExpression('\'stable\''),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    fiatCurrencyCode,
    bitcoinUnit,
    languageTag,
    themeMode,
    hideAmounts,
    environmentMode,
    superuserModeEnabled,
    featureLevel,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'app_settings';
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AppSettingsData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AppSettingsData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      fiatCurrencyCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}fiat_currency_code'],
      )!,
      bitcoinUnit: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bitcoin_unit'],
      )!,
      languageTag: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}language_tag'],
      )!,
      themeMode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}theme_mode'],
      )!,
      hideAmounts: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}hide_amounts'],
      )!,
      environmentMode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}environment_mode'],
      )!,
      superuserModeEnabled: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}superuser_mode_enabled'],
      )!,
      featureLevel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}feature_level'],
      )!,
    );
  }

  @override
  AppSettings createAlias(String alias) {
    return AppSettings(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AppSettingsData extends DataClass implements Insertable<AppSettingsData> {
  final int id;
  final String fiatCurrencyCode;
  final String bitcoinUnit;
  final String languageTag;
  final String themeMode;
  final int hideAmounts;
  final String environmentMode;
  final int superuserModeEnabled;
  final String featureLevel;
  const AppSettingsData({
    required this.id,
    required this.fiatCurrencyCode,
    required this.bitcoinUnit,
    required this.languageTag,
    required this.themeMode,
    required this.hideAmounts,
    required this.environmentMode,
    required this.superuserModeEnabled,
    required this.featureLevel,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['fiat_currency_code'] = Variable<String>(fiatCurrencyCode);
    map['bitcoin_unit'] = Variable<String>(bitcoinUnit);
    map['language_tag'] = Variable<String>(languageTag);
    map['theme_mode'] = Variable<String>(themeMode);
    map['hide_amounts'] = Variable<int>(hideAmounts);
    map['environment_mode'] = Variable<String>(environmentMode);
    map['superuser_mode_enabled'] = Variable<int>(superuserModeEnabled);
    map['feature_level'] = Variable<String>(featureLevel);
    return map;
  }

  AppSettingsCompanion toCompanion(bool nullToAbsent) {
    return AppSettingsCompanion(
      id: Value(id),
      fiatCurrencyCode: Value(fiatCurrencyCode),
      bitcoinUnit: Value(bitcoinUnit),
      languageTag: Value(languageTag),
      themeMode: Value(themeMode),
      hideAmounts: Value(hideAmounts),
      environmentMode: Value(environmentMode),
      superuserModeEnabled: Value(superuserModeEnabled),
      featureLevel: Value(featureLevel),
    );
  }

  factory AppSettingsData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AppSettingsData(
      id: serializer.fromJson<int>(json['id']),
      fiatCurrencyCode: serializer.fromJson<String>(json['fiatCurrencyCode']),
      bitcoinUnit: serializer.fromJson<String>(json['bitcoinUnit']),
      languageTag: serializer.fromJson<String>(json['languageTag']),
      themeMode: serializer.fromJson<String>(json['themeMode']),
      hideAmounts: serializer.fromJson<int>(json['hideAmounts']),
      environmentMode: serializer.fromJson<String>(json['environmentMode']),
      superuserModeEnabled: serializer.fromJson<int>(
        json['superuserModeEnabled'],
      ),
      featureLevel: serializer.fromJson<String>(json['featureLevel']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'fiatCurrencyCode': serializer.toJson<String>(fiatCurrencyCode),
      'bitcoinUnit': serializer.toJson<String>(bitcoinUnit),
      'languageTag': serializer.toJson<String>(languageTag),
      'themeMode': serializer.toJson<String>(themeMode),
      'hideAmounts': serializer.toJson<int>(hideAmounts),
      'environmentMode': serializer.toJson<String>(environmentMode),
      'superuserModeEnabled': serializer.toJson<int>(superuserModeEnabled),
      'featureLevel': serializer.toJson<String>(featureLevel),
    };
  }

  AppSettingsData copyWith({
    int? id,
    String? fiatCurrencyCode,
    String? bitcoinUnit,
    String? languageTag,
    String? themeMode,
    int? hideAmounts,
    String? environmentMode,
    int? superuserModeEnabled,
    String? featureLevel,
  }) => AppSettingsData(
    id: id ?? this.id,
    fiatCurrencyCode: fiatCurrencyCode ?? this.fiatCurrencyCode,
    bitcoinUnit: bitcoinUnit ?? this.bitcoinUnit,
    languageTag: languageTag ?? this.languageTag,
    themeMode: themeMode ?? this.themeMode,
    hideAmounts: hideAmounts ?? this.hideAmounts,
    environmentMode: environmentMode ?? this.environmentMode,
    superuserModeEnabled: superuserModeEnabled ?? this.superuserModeEnabled,
    featureLevel: featureLevel ?? this.featureLevel,
  );
  AppSettingsData copyWithCompanion(AppSettingsCompanion data) {
    return AppSettingsData(
      id: data.id.present ? data.id.value : this.id,
      fiatCurrencyCode: data.fiatCurrencyCode.present
          ? data.fiatCurrencyCode.value
          : this.fiatCurrencyCode,
      bitcoinUnit: data.bitcoinUnit.present
          ? data.bitcoinUnit.value
          : this.bitcoinUnit,
      languageTag: data.languageTag.present
          ? data.languageTag.value
          : this.languageTag,
      themeMode: data.themeMode.present ? data.themeMode.value : this.themeMode,
      hideAmounts: data.hideAmounts.present
          ? data.hideAmounts.value
          : this.hideAmounts,
      environmentMode: data.environmentMode.present
          ? data.environmentMode.value
          : this.environmentMode,
      superuserModeEnabled: data.superuserModeEnabled.present
          ? data.superuserModeEnabled.value
          : this.superuserModeEnabled,
      featureLevel: data.featureLevel.present
          ? data.featureLevel.value
          : this.featureLevel,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AppSettingsData(')
          ..write('id: $id, ')
          ..write('fiatCurrencyCode: $fiatCurrencyCode, ')
          ..write('bitcoinUnit: $bitcoinUnit, ')
          ..write('languageTag: $languageTag, ')
          ..write('themeMode: $themeMode, ')
          ..write('hideAmounts: $hideAmounts, ')
          ..write('environmentMode: $environmentMode, ')
          ..write('superuserModeEnabled: $superuserModeEnabled, ')
          ..write('featureLevel: $featureLevel')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    fiatCurrencyCode,
    bitcoinUnit,
    languageTag,
    themeMode,
    hideAmounts,
    environmentMode,
    superuserModeEnabled,
    featureLevel,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AppSettingsData &&
          other.id == this.id &&
          other.fiatCurrencyCode == this.fiatCurrencyCode &&
          other.bitcoinUnit == this.bitcoinUnit &&
          other.languageTag == this.languageTag &&
          other.themeMode == this.themeMode &&
          other.hideAmounts == this.hideAmounts &&
          other.environmentMode == this.environmentMode &&
          other.superuserModeEnabled == this.superuserModeEnabled &&
          other.featureLevel == this.featureLevel);
}

class AppSettingsCompanion extends UpdateCompanion<AppSettingsData> {
  final Value<int> id;
  final Value<String> fiatCurrencyCode;
  final Value<String> bitcoinUnit;
  final Value<String> languageTag;
  final Value<String> themeMode;
  final Value<int> hideAmounts;
  final Value<String> environmentMode;
  final Value<int> superuserModeEnabled;
  final Value<String> featureLevel;
  const AppSettingsCompanion({
    this.id = const Value.absent(),
    this.fiatCurrencyCode = const Value.absent(),
    this.bitcoinUnit = const Value.absent(),
    this.languageTag = const Value.absent(),
    this.themeMode = const Value.absent(),
    this.hideAmounts = const Value.absent(),
    this.environmentMode = const Value.absent(),
    this.superuserModeEnabled = const Value.absent(),
    this.featureLevel = const Value.absent(),
  });
  AppSettingsCompanion.insert({
    this.id = const Value.absent(),
    this.fiatCurrencyCode = const Value.absent(),
    this.bitcoinUnit = const Value.absent(),
    this.languageTag = const Value.absent(),
    this.themeMode = const Value.absent(),
    this.hideAmounts = const Value.absent(),
    this.environmentMode = const Value.absent(),
    this.superuserModeEnabled = const Value.absent(),
    this.featureLevel = const Value.absent(),
  });
  static Insertable<AppSettingsData> custom({
    Expression<int>? id,
    Expression<String>? fiatCurrencyCode,
    Expression<String>? bitcoinUnit,
    Expression<String>? languageTag,
    Expression<String>? themeMode,
    Expression<int>? hideAmounts,
    Expression<String>? environmentMode,
    Expression<int>? superuserModeEnabled,
    Expression<String>? featureLevel,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (fiatCurrencyCode != null) 'fiat_currency_code': fiatCurrencyCode,
      if (bitcoinUnit != null) 'bitcoin_unit': bitcoinUnit,
      if (languageTag != null) 'language_tag': languageTag,
      if (themeMode != null) 'theme_mode': themeMode,
      if (hideAmounts != null) 'hide_amounts': hideAmounts,
      if (environmentMode != null) 'environment_mode': environmentMode,
      if (superuserModeEnabled != null)
        'superuser_mode_enabled': superuserModeEnabled,
      if (featureLevel != null) 'feature_level': featureLevel,
    });
  }

  AppSettingsCompanion copyWith({
    Value<int>? id,
    Value<String>? fiatCurrencyCode,
    Value<String>? bitcoinUnit,
    Value<String>? languageTag,
    Value<String>? themeMode,
    Value<int>? hideAmounts,
    Value<String>? environmentMode,
    Value<int>? superuserModeEnabled,
    Value<String>? featureLevel,
  }) {
    return AppSettingsCompanion(
      id: id ?? this.id,
      fiatCurrencyCode: fiatCurrencyCode ?? this.fiatCurrencyCode,
      bitcoinUnit: bitcoinUnit ?? this.bitcoinUnit,
      languageTag: languageTag ?? this.languageTag,
      themeMode: themeMode ?? this.themeMode,
      hideAmounts: hideAmounts ?? this.hideAmounts,
      environmentMode: environmentMode ?? this.environmentMode,
      superuserModeEnabled: superuserModeEnabled ?? this.superuserModeEnabled,
      featureLevel: featureLevel ?? this.featureLevel,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (fiatCurrencyCode.present) {
      map['fiat_currency_code'] = Variable<String>(fiatCurrencyCode.value);
    }
    if (bitcoinUnit.present) {
      map['bitcoin_unit'] = Variable<String>(bitcoinUnit.value);
    }
    if (languageTag.present) {
      map['language_tag'] = Variable<String>(languageTag.value);
    }
    if (themeMode.present) {
      map['theme_mode'] = Variable<String>(themeMode.value);
    }
    if (hideAmounts.present) {
      map['hide_amounts'] = Variable<int>(hideAmounts.value);
    }
    if (environmentMode.present) {
      map['environment_mode'] = Variable<String>(environmentMode.value);
    }
    if (superuserModeEnabled.present) {
      map['superuser_mode_enabled'] = Variable<int>(superuserModeEnabled.value);
    }
    if (featureLevel.present) {
      map['feature_level'] = Variable<String>(featureLevel.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AppSettingsCompanion(')
          ..write('id: $id, ')
          ..write('fiatCurrencyCode: $fiatCurrencyCode, ')
          ..write('bitcoinUnit: $bitcoinUnit, ')
          ..write('languageTag: $languageTag, ')
          ..write('themeMode: $themeMode, ')
          ..write('hideAmounts: $hideAmounts, ')
          ..write('environmentMode: $environmentMode, ')
          ..write('superuserModeEnabled: $superuserModeEnabled, ')
          ..write('featureLevel: $featureLevel')
          ..write(')'))
        .toString();
  }
}

class PayjoinSenders extends Table
    with TableInfo<PayjoinSenders, PayjoinSendersData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  PayjoinSenders(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<String> uri = GeneratedColumn<String>(
    'uri',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> isTestnet = GeneratedColumn<int>(
    'is_testnet',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_testnet IN (0, 1))',
  );
  late final GeneratedColumn<String> sender = GeneratedColumn<String>(
    'sender',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> walletId = GeneratedColumn<String>(
    'wallet_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> originalPsbt = GeneratedColumn<String>(
    'original_psbt',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> originalTxId = GeneratedColumn<String>(
    'original_tx_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> amountSat = GeneratedColumn<int>(
    'amount_sat',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> expireAfterSec = GeneratedColumn<int>(
    'expire_after_sec',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> proposalPsbt = GeneratedColumn<String>(
    'proposal_psbt',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> txId = GeneratedColumn<String>(
    'tx_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<int> isExpired = GeneratedColumn<int>(
    'is_expired',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_expired IN (0, 1))',
  );
  late final GeneratedColumn<int> isCompleted = GeneratedColumn<int>(
    'is_completed',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_completed IN (0, 1))',
  );
  @override
  List<GeneratedColumn> get $columns => [
    uri,
    isTestnet,
    sender,
    walletId,
    originalPsbt,
    originalTxId,
    amountSat,
    createdAt,
    expireAfterSec,
    proposalPsbt,
    txId,
    isExpired,
    isCompleted,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'payjoin_senders';
  @override
  Set<GeneratedColumn> get $primaryKey => {uri};
  @override
  PayjoinSendersData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PayjoinSendersData(
      uri: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uri'],
      )!,
      isTestnet: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_testnet'],
      )!,
      sender: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sender'],
      )!,
      walletId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}wallet_id'],
      )!,
      originalPsbt: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}original_psbt'],
      )!,
      originalTxId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}original_tx_id'],
      )!,
      amountSat: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}amount_sat'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      expireAfterSec: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}expire_after_sec'],
      )!,
      proposalPsbt: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}proposal_psbt'],
      ),
      txId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}tx_id'],
      ),
      isExpired: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_expired'],
      )!,
      isCompleted: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_completed'],
      )!,
    );
  }

  @override
  PayjoinSenders createAlias(String alias) {
    return PayjoinSenders(attachedDatabase, alias);
  }

  @override
  List<String> get customConstraints => const ['PRIMARY KEY(uri)'];
  @override
  bool get dontWriteConstraints => true;
}

class PayjoinSendersData extends DataClass
    implements Insertable<PayjoinSendersData> {
  final String uri;
  final int isTestnet;
  final String sender;
  final String walletId;
  final String originalPsbt;
  final String originalTxId;
  final int amountSat;
  final int createdAt;
  final int expireAfterSec;
  final String? proposalPsbt;
  final String? txId;
  final int isExpired;
  final int isCompleted;
  const PayjoinSendersData({
    required this.uri,
    required this.isTestnet,
    required this.sender,
    required this.walletId,
    required this.originalPsbt,
    required this.originalTxId,
    required this.amountSat,
    required this.createdAt,
    required this.expireAfterSec,
    this.proposalPsbt,
    this.txId,
    required this.isExpired,
    required this.isCompleted,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uri'] = Variable<String>(uri);
    map['is_testnet'] = Variable<int>(isTestnet);
    map['sender'] = Variable<String>(sender);
    map['wallet_id'] = Variable<String>(walletId);
    map['original_psbt'] = Variable<String>(originalPsbt);
    map['original_tx_id'] = Variable<String>(originalTxId);
    map['amount_sat'] = Variable<int>(amountSat);
    map['created_at'] = Variable<int>(createdAt);
    map['expire_after_sec'] = Variable<int>(expireAfterSec);
    if (!nullToAbsent || proposalPsbt != null) {
      map['proposal_psbt'] = Variable<String>(proposalPsbt);
    }
    if (!nullToAbsent || txId != null) {
      map['tx_id'] = Variable<String>(txId);
    }
    map['is_expired'] = Variable<int>(isExpired);
    map['is_completed'] = Variable<int>(isCompleted);
    return map;
  }

  PayjoinSendersCompanion toCompanion(bool nullToAbsent) {
    return PayjoinSendersCompanion(
      uri: Value(uri),
      isTestnet: Value(isTestnet),
      sender: Value(sender),
      walletId: Value(walletId),
      originalPsbt: Value(originalPsbt),
      originalTxId: Value(originalTxId),
      amountSat: Value(amountSat),
      createdAt: Value(createdAt),
      expireAfterSec: Value(expireAfterSec),
      proposalPsbt: proposalPsbt == null && nullToAbsent
          ? const Value.absent()
          : Value(proposalPsbt),
      txId: txId == null && nullToAbsent ? const Value.absent() : Value(txId),
      isExpired: Value(isExpired),
      isCompleted: Value(isCompleted),
    );
  }

  factory PayjoinSendersData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PayjoinSendersData(
      uri: serializer.fromJson<String>(json['uri']),
      isTestnet: serializer.fromJson<int>(json['isTestnet']),
      sender: serializer.fromJson<String>(json['sender']),
      walletId: serializer.fromJson<String>(json['walletId']),
      originalPsbt: serializer.fromJson<String>(json['originalPsbt']),
      originalTxId: serializer.fromJson<String>(json['originalTxId']),
      amountSat: serializer.fromJson<int>(json['amountSat']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      expireAfterSec: serializer.fromJson<int>(json['expireAfterSec']),
      proposalPsbt: serializer.fromJson<String?>(json['proposalPsbt']),
      txId: serializer.fromJson<String?>(json['txId']),
      isExpired: serializer.fromJson<int>(json['isExpired']),
      isCompleted: serializer.fromJson<int>(json['isCompleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uri': serializer.toJson<String>(uri),
      'isTestnet': serializer.toJson<int>(isTestnet),
      'sender': serializer.toJson<String>(sender),
      'walletId': serializer.toJson<String>(walletId),
      'originalPsbt': serializer.toJson<String>(originalPsbt),
      'originalTxId': serializer.toJson<String>(originalTxId),
      'amountSat': serializer.toJson<int>(amountSat),
      'createdAt': serializer.toJson<int>(createdAt),
      'expireAfterSec': serializer.toJson<int>(expireAfterSec),
      'proposalPsbt': serializer.toJson<String?>(proposalPsbt),
      'txId': serializer.toJson<String?>(txId),
      'isExpired': serializer.toJson<int>(isExpired),
      'isCompleted': serializer.toJson<int>(isCompleted),
    };
  }

  PayjoinSendersData copyWith({
    String? uri,
    int? isTestnet,
    String? sender,
    String? walletId,
    String? originalPsbt,
    String? originalTxId,
    int? amountSat,
    int? createdAt,
    int? expireAfterSec,
    Value<String?> proposalPsbt = const Value.absent(),
    Value<String?> txId = const Value.absent(),
    int? isExpired,
    int? isCompleted,
  }) => PayjoinSendersData(
    uri: uri ?? this.uri,
    isTestnet: isTestnet ?? this.isTestnet,
    sender: sender ?? this.sender,
    walletId: walletId ?? this.walletId,
    originalPsbt: originalPsbt ?? this.originalPsbt,
    originalTxId: originalTxId ?? this.originalTxId,
    amountSat: amountSat ?? this.amountSat,
    createdAt: createdAt ?? this.createdAt,
    expireAfterSec: expireAfterSec ?? this.expireAfterSec,
    proposalPsbt: proposalPsbt.present ? proposalPsbt.value : this.proposalPsbt,
    txId: txId.present ? txId.value : this.txId,
    isExpired: isExpired ?? this.isExpired,
    isCompleted: isCompleted ?? this.isCompleted,
  );
  PayjoinSendersData copyWithCompanion(PayjoinSendersCompanion data) {
    return PayjoinSendersData(
      uri: data.uri.present ? data.uri.value : this.uri,
      isTestnet: data.isTestnet.present ? data.isTestnet.value : this.isTestnet,
      sender: data.sender.present ? data.sender.value : this.sender,
      walletId: data.walletId.present ? data.walletId.value : this.walletId,
      originalPsbt: data.originalPsbt.present
          ? data.originalPsbt.value
          : this.originalPsbt,
      originalTxId: data.originalTxId.present
          ? data.originalTxId.value
          : this.originalTxId,
      amountSat: data.amountSat.present ? data.amountSat.value : this.amountSat,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      expireAfterSec: data.expireAfterSec.present
          ? data.expireAfterSec.value
          : this.expireAfterSec,
      proposalPsbt: data.proposalPsbt.present
          ? data.proposalPsbt.value
          : this.proposalPsbt,
      txId: data.txId.present ? data.txId.value : this.txId,
      isExpired: data.isExpired.present ? data.isExpired.value : this.isExpired,
      isCompleted: data.isCompleted.present
          ? data.isCompleted.value
          : this.isCompleted,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PayjoinSendersData(')
          ..write('uri: $uri, ')
          ..write('isTestnet: $isTestnet, ')
          ..write('sender: $sender, ')
          ..write('walletId: $walletId, ')
          ..write('originalPsbt: $originalPsbt, ')
          ..write('originalTxId: $originalTxId, ')
          ..write('amountSat: $amountSat, ')
          ..write('createdAt: $createdAt, ')
          ..write('expireAfterSec: $expireAfterSec, ')
          ..write('proposalPsbt: $proposalPsbt, ')
          ..write('txId: $txId, ')
          ..write('isExpired: $isExpired, ')
          ..write('isCompleted: $isCompleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uri,
    isTestnet,
    sender,
    walletId,
    originalPsbt,
    originalTxId,
    amountSat,
    createdAt,
    expireAfterSec,
    proposalPsbt,
    txId,
    isExpired,
    isCompleted,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PayjoinSendersData &&
          other.uri == this.uri &&
          other.isTestnet == this.isTestnet &&
          other.sender == this.sender &&
          other.walletId == this.walletId &&
          other.originalPsbt == this.originalPsbt &&
          other.originalTxId == this.originalTxId &&
          other.amountSat == this.amountSat &&
          other.createdAt == this.createdAt &&
          other.expireAfterSec == this.expireAfterSec &&
          other.proposalPsbt == this.proposalPsbt &&
          other.txId == this.txId &&
          other.isExpired == this.isExpired &&
          other.isCompleted == this.isCompleted);
}

class PayjoinSendersCompanion extends UpdateCompanion<PayjoinSendersData> {
  final Value<String> uri;
  final Value<int> isTestnet;
  final Value<String> sender;
  final Value<String> walletId;
  final Value<String> originalPsbt;
  final Value<String> originalTxId;
  final Value<int> amountSat;
  final Value<int> createdAt;
  final Value<int> expireAfterSec;
  final Value<String?> proposalPsbt;
  final Value<String?> txId;
  final Value<int> isExpired;
  final Value<int> isCompleted;
  final Value<int> rowid;
  const PayjoinSendersCompanion({
    this.uri = const Value.absent(),
    this.isTestnet = const Value.absent(),
    this.sender = const Value.absent(),
    this.walletId = const Value.absent(),
    this.originalPsbt = const Value.absent(),
    this.originalTxId = const Value.absent(),
    this.amountSat = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.expireAfterSec = const Value.absent(),
    this.proposalPsbt = const Value.absent(),
    this.txId = const Value.absent(),
    this.isExpired = const Value.absent(),
    this.isCompleted = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PayjoinSendersCompanion.insert({
    required String uri,
    required int isTestnet,
    required String sender,
    required String walletId,
    required String originalPsbt,
    required String originalTxId,
    required int amountSat,
    required int createdAt,
    required int expireAfterSec,
    this.proposalPsbt = const Value.absent(),
    this.txId = const Value.absent(),
    required int isExpired,
    required int isCompleted,
    this.rowid = const Value.absent(),
  }) : uri = Value(uri),
       isTestnet = Value(isTestnet),
       sender = Value(sender),
       walletId = Value(walletId),
       originalPsbt = Value(originalPsbt),
       originalTxId = Value(originalTxId),
       amountSat = Value(amountSat),
       createdAt = Value(createdAt),
       expireAfterSec = Value(expireAfterSec),
       isExpired = Value(isExpired),
       isCompleted = Value(isCompleted);
  static Insertable<PayjoinSendersData> custom({
    Expression<String>? uri,
    Expression<int>? isTestnet,
    Expression<String>? sender,
    Expression<String>? walletId,
    Expression<String>? originalPsbt,
    Expression<String>? originalTxId,
    Expression<int>? amountSat,
    Expression<int>? createdAt,
    Expression<int>? expireAfterSec,
    Expression<String>? proposalPsbt,
    Expression<String>? txId,
    Expression<int>? isExpired,
    Expression<int>? isCompleted,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uri != null) 'uri': uri,
      if (isTestnet != null) 'is_testnet': isTestnet,
      if (sender != null) 'sender': sender,
      if (walletId != null) 'wallet_id': walletId,
      if (originalPsbt != null) 'original_psbt': originalPsbt,
      if (originalTxId != null) 'original_tx_id': originalTxId,
      if (amountSat != null) 'amount_sat': amountSat,
      if (createdAt != null) 'created_at': createdAt,
      if (expireAfterSec != null) 'expire_after_sec': expireAfterSec,
      if (proposalPsbt != null) 'proposal_psbt': proposalPsbt,
      if (txId != null) 'tx_id': txId,
      if (isExpired != null) 'is_expired': isExpired,
      if (isCompleted != null) 'is_completed': isCompleted,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PayjoinSendersCompanion copyWith({
    Value<String>? uri,
    Value<int>? isTestnet,
    Value<String>? sender,
    Value<String>? walletId,
    Value<String>? originalPsbt,
    Value<String>? originalTxId,
    Value<int>? amountSat,
    Value<int>? createdAt,
    Value<int>? expireAfterSec,
    Value<String?>? proposalPsbt,
    Value<String?>? txId,
    Value<int>? isExpired,
    Value<int>? isCompleted,
    Value<int>? rowid,
  }) {
    return PayjoinSendersCompanion(
      uri: uri ?? this.uri,
      isTestnet: isTestnet ?? this.isTestnet,
      sender: sender ?? this.sender,
      walletId: walletId ?? this.walletId,
      originalPsbt: originalPsbt ?? this.originalPsbt,
      originalTxId: originalTxId ?? this.originalTxId,
      amountSat: amountSat ?? this.amountSat,
      createdAt: createdAt ?? this.createdAt,
      expireAfterSec: expireAfterSec ?? this.expireAfterSec,
      proposalPsbt: proposalPsbt ?? this.proposalPsbt,
      txId: txId ?? this.txId,
      isExpired: isExpired ?? this.isExpired,
      isCompleted: isCompleted ?? this.isCompleted,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uri.present) {
      map['uri'] = Variable<String>(uri.value);
    }
    if (isTestnet.present) {
      map['is_testnet'] = Variable<int>(isTestnet.value);
    }
    if (sender.present) {
      map['sender'] = Variable<String>(sender.value);
    }
    if (walletId.present) {
      map['wallet_id'] = Variable<String>(walletId.value);
    }
    if (originalPsbt.present) {
      map['original_psbt'] = Variable<String>(originalPsbt.value);
    }
    if (originalTxId.present) {
      map['original_tx_id'] = Variable<String>(originalTxId.value);
    }
    if (amountSat.present) {
      map['amount_sat'] = Variable<int>(amountSat.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (expireAfterSec.present) {
      map['expire_after_sec'] = Variable<int>(expireAfterSec.value);
    }
    if (proposalPsbt.present) {
      map['proposal_psbt'] = Variable<String>(proposalPsbt.value);
    }
    if (txId.present) {
      map['tx_id'] = Variable<String>(txId.value);
    }
    if (isExpired.present) {
      map['is_expired'] = Variable<int>(isExpired.value);
    }
    if (isCompleted.present) {
      map['is_completed'] = Variable<int>(isCompleted.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PayjoinSendersCompanion(')
          ..write('uri: $uri, ')
          ..write('isTestnet: $isTestnet, ')
          ..write('sender: $sender, ')
          ..write('walletId: $walletId, ')
          ..write('originalPsbt: $originalPsbt, ')
          ..write('originalTxId: $originalTxId, ')
          ..write('amountSat: $amountSat, ')
          ..write('createdAt: $createdAt, ')
          ..write('expireAfterSec: $expireAfterSec, ')
          ..write('proposalPsbt: $proposalPsbt, ')
          ..write('txId: $txId, ')
          ..write('isExpired: $isExpired, ')
          ..write('isCompleted: $isCompleted, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class PayjoinReceivers extends Table
    with TableInfo<PayjoinReceivers, PayjoinReceiversData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  PayjoinReceivers(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
    'address',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> isTestnet = GeneratedColumn<int>(
    'is_testnet',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_testnet IN (0, 1))',
  );
  late final GeneratedColumn<String> receiver = GeneratedColumn<String>(
    'receiver',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> walletId = GeneratedColumn<String>(
    'wallet_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> pjUri = GeneratedColumn<String>(
    'pj_uri',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> maxFeeRateSatPerVb = GeneratedColumn<int>(
    'max_fee_rate_sat_per_vb',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> expireAfterSec = GeneratedColumn<int>(
    'expire_after_sec',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<i2.Uint8List> originalTxBytes =
      GeneratedColumn<i2.Uint8List>(
        'original_tx_bytes',
        aliasedName,
        true,
        type: DriftSqlType.blob,
        requiredDuringInsert: false,
        $customConstraints: 'NULL',
      );
  late final GeneratedColumn<String> originalTxId = GeneratedColumn<String>(
    'original_tx_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<int> amountSat = GeneratedColumn<int>(
    'amount_sat',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> proposalPsbt = GeneratedColumn<String>(
    'proposal_psbt',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> txId = GeneratedColumn<String>(
    'tx_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<int> isExpired = GeneratedColumn<int>(
    'is_expired',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_expired IN (0, 1))',
  );
  late final GeneratedColumn<int> isCompleted = GeneratedColumn<int>(
    'is_completed',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_completed IN (0, 1))',
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    address,
    isTestnet,
    receiver,
    walletId,
    pjUri,
    maxFeeRateSatPerVb,
    createdAt,
    expireAfterSec,
    originalTxBytes,
    originalTxId,
    amountSat,
    proposalPsbt,
    txId,
    isExpired,
    isCompleted,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'payjoin_receivers';
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PayjoinReceiversData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PayjoinReceiversData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      address: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}address'],
      )!,
      isTestnet: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_testnet'],
      )!,
      receiver: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}receiver'],
      )!,
      walletId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}wallet_id'],
      )!,
      pjUri: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}pj_uri'],
      )!,
      maxFeeRateSatPerVb: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}max_fee_rate_sat_per_vb'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      expireAfterSec: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}expire_after_sec'],
      )!,
      originalTxBytes: attachedDatabase.typeMapping.read(
        DriftSqlType.blob,
        data['${effectivePrefix}original_tx_bytes'],
      ),
      originalTxId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}original_tx_id'],
      ),
      amountSat: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}amount_sat'],
      ),
      proposalPsbt: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}proposal_psbt'],
      ),
      txId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}tx_id'],
      ),
      isExpired: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_expired'],
      )!,
      isCompleted: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_completed'],
      )!,
    );
  }

  @override
  PayjoinReceivers createAlias(String alias) {
    return PayjoinReceivers(attachedDatabase, alias);
  }

  @override
  List<String> get customConstraints => const ['PRIMARY KEY(id)'];
  @override
  bool get dontWriteConstraints => true;
}

class PayjoinReceiversData extends DataClass
    implements Insertable<PayjoinReceiversData> {
  final String id;
  final String address;
  final int isTestnet;
  final String receiver;
  final String walletId;
  final String pjUri;
  final int maxFeeRateSatPerVb;
  final int createdAt;
  final int expireAfterSec;
  final i2.Uint8List? originalTxBytes;
  final String? originalTxId;
  final int? amountSat;
  final String? proposalPsbt;
  final String? txId;
  final int isExpired;
  final int isCompleted;
  const PayjoinReceiversData({
    required this.id,
    required this.address,
    required this.isTestnet,
    required this.receiver,
    required this.walletId,
    required this.pjUri,
    required this.maxFeeRateSatPerVb,
    required this.createdAt,
    required this.expireAfterSec,
    this.originalTxBytes,
    this.originalTxId,
    this.amountSat,
    this.proposalPsbt,
    this.txId,
    required this.isExpired,
    required this.isCompleted,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['address'] = Variable<String>(address);
    map['is_testnet'] = Variable<int>(isTestnet);
    map['receiver'] = Variable<String>(receiver);
    map['wallet_id'] = Variable<String>(walletId);
    map['pj_uri'] = Variable<String>(pjUri);
    map['max_fee_rate_sat_per_vb'] = Variable<int>(maxFeeRateSatPerVb);
    map['created_at'] = Variable<int>(createdAt);
    map['expire_after_sec'] = Variable<int>(expireAfterSec);
    if (!nullToAbsent || originalTxBytes != null) {
      map['original_tx_bytes'] = Variable<i2.Uint8List>(originalTxBytes);
    }
    if (!nullToAbsent || originalTxId != null) {
      map['original_tx_id'] = Variable<String>(originalTxId);
    }
    if (!nullToAbsent || amountSat != null) {
      map['amount_sat'] = Variable<int>(amountSat);
    }
    if (!nullToAbsent || proposalPsbt != null) {
      map['proposal_psbt'] = Variable<String>(proposalPsbt);
    }
    if (!nullToAbsent || txId != null) {
      map['tx_id'] = Variable<String>(txId);
    }
    map['is_expired'] = Variable<int>(isExpired);
    map['is_completed'] = Variable<int>(isCompleted);
    return map;
  }

  PayjoinReceiversCompanion toCompanion(bool nullToAbsent) {
    return PayjoinReceiversCompanion(
      id: Value(id),
      address: Value(address),
      isTestnet: Value(isTestnet),
      receiver: Value(receiver),
      walletId: Value(walletId),
      pjUri: Value(pjUri),
      maxFeeRateSatPerVb: Value(maxFeeRateSatPerVb),
      createdAt: Value(createdAt),
      expireAfterSec: Value(expireAfterSec),
      originalTxBytes: originalTxBytes == null && nullToAbsent
          ? const Value.absent()
          : Value(originalTxBytes),
      originalTxId: originalTxId == null && nullToAbsent
          ? const Value.absent()
          : Value(originalTxId),
      amountSat: amountSat == null && nullToAbsent
          ? const Value.absent()
          : Value(amountSat),
      proposalPsbt: proposalPsbt == null && nullToAbsent
          ? const Value.absent()
          : Value(proposalPsbt),
      txId: txId == null && nullToAbsent ? const Value.absent() : Value(txId),
      isExpired: Value(isExpired),
      isCompleted: Value(isCompleted),
    );
  }

  factory PayjoinReceiversData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PayjoinReceiversData(
      id: serializer.fromJson<String>(json['id']),
      address: serializer.fromJson<String>(json['address']),
      isTestnet: serializer.fromJson<int>(json['isTestnet']),
      receiver: serializer.fromJson<String>(json['receiver']),
      walletId: serializer.fromJson<String>(json['walletId']),
      pjUri: serializer.fromJson<String>(json['pjUri']),
      maxFeeRateSatPerVb: serializer.fromJson<int>(json['maxFeeRateSatPerVb']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      expireAfterSec: serializer.fromJson<int>(json['expireAfterSec']),
      originalTxBytes: serializer.fromJson<i2.Uint8List?>(
        json['originalTxBytes'],
      ),
      originalTxId: serializer.fromJson<String?>(json['originalTxId']),
      amountSat: serializer.fromJson<int?>(json['amountSat']),
      proposalPsbt: serializer.fromJson<String?>(json['proposalPsbt']),
      txId: serializer.fromJson<String?>(json['txId']),
      isExpired: serializer.fromJson<int>(json['isExpired']),
      isCompleted: serializer.fromJson<int>(json['isCompleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'address': serializer.toJson<String>(address),
      'isTestnet': serializer.toJson<int>(isTestnet),
      'receiver': serializer.toJson<String>(receiver),
      'walletId': serializer.toJson<String>(walletId),
      'pjUri': serializer.toJson<String>(pjUri),
      'maxFeeRateSatPerVb': serializer.toJson<int>(maxFeeRateSatPerVb),
      'createdAt': serializer.toJson<int>(createdAt),
      'expireAfterSec': serializer.toJson<int>(expireAfterSec),
      'originalTxBytes': serializer.toJson<i2.Uint8List?>(originalTxBytes),
      'originalTxId': serializer.toJson<String?>(originalTxId),
      'amountSat': serializer.toJson<int?>(amountSat),
      'proposalPsbt': serializer.toJson<String?>(proposalPsbt),
      'txId': serializer.toJson<String?>(txId),
      'isExpired': serializer.toJson<int>(isExpired),
      'isCompleted': serializer.toJson<int>(isCompleted),
    };
  }

  PayjoinReceiversData copyWith({
    String? id,
    String? address,
    int? isTestnet,
    String? receiver,
    String? walletId,
    String? pjUri,
    int? maxFeeRateSatPerVb,
    int? createdAt,
    int? expireAfterSec,
    Value<i2.Uint8List?> originalTxBytes = const Value.absent(),
    Value<String?> originalTxId = const Value.absent(),
    Value<int?> amountSat = const Value.absent(),
    Value<String?> proposalPsbt = const Value.absent(),
    Value<String?> txId = const Value.absent(),
    int? isExpired,
    int? isCompleted,
  }) => PayjoinReceiversData(
    id: id ?? this.id,
    address: address ?? this.address,
    isTestnet: isTestnet ?? this.isTestnet,
    receiver: receiver ?? this.receiver,
    walletId: walletId ?? this.walletId,
    pjUri: pjUri ?? this.pjUri,
    maxFeeRateSatPerVb: maxFeeRateSatPerVb ?? this.maxFeeRateSatPerVb,
    createdAt: createdAt ?? this.createdAt,
    expireAfterSec: expireAfterSec ?? this.expireAfterSec,
    originalTxBytes: originalTxBytes.present
        ? originalTxBytes.value
        : this.originalTxBytes,
    originalTxId: originalTxId.present ? originalTxId.value : this.originalTxId,
    amountSat: amountSat.present ? amountSat.value : this.amountSat,
    proposalPsbt: proposalPsbt.present ? proposalPsbt.value : this.proposalPsbt,
    txId: txId.present ? txId.value : this.txId,
    isExpired: isExpired ?? this.isExpired,
    isCompleted: isCompleted ?? this.isCompleted,
  );
  PayjoinReceiversData copyWithCompanion(PayjoinReceiversCompanion data) {
    return PayjoinReceiversData(
      id: data.id.present ? data.id.value : this.id,
      address: data.address.present ? data.address.value : this.address,
      isTestnet: data.isTestnet.present ? data.isTestnet.value : this.isTestnet,
      receiver: data.receiver.present ? data.receiver.value : this.receiver,
      walletId: data.walletId.present ? data.walletId.value : this.walletId,
      pjUri: data.pjUri.present ? data.pjUri.value : this.pjUri,
      maxFeeRateSatPerVb: data.maxFeeRateSatPerVb.present
          ? data.maxFeeRateSatPerVb.value
          : this.maxFeeRateSatPerVb,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      expireAfterSec: data.expireAfterSec.present
          ? data.expireAfterSec.value
          : this.expireAfterSec,
      originalTxBytes: data.originalTxBytes.present
          ? data.originalTxBytes.value
          : this.originalTxBytes,
      originalTxId: data.originalTxId.present
          ? data.originalTxId.value
          : this.originalTxId,
      amountSat: data.amountSat.present ? data.amountSat.value : this.amountSat,
      proposalPsbt: data.proposalPsbt.present
          ? data.proposalPsbt.value
          : this.proposalPsbt,
      txId: data.txId.present ? data.txId.value : this.txId,
      isExpired: data.isExpired.present ? data.isExpired.value : this.isExpired,
      isCompleted: data.isCompleted.present
          ? data.isCompleted.value
          : this.isCompleted,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PayjoinReceiversData(')
          ..write('id: $id, ')
          ..write('address: $address, ')
          ..write('isTestnet: $isTestnet, ')
          ..write('receiver: $receiver, ')
          ..write('walletId: $walletId, ')
          ..write('pjUri: $pjUri, ')
          ..write('maxFeeRateSatPerVb: $maxFeeRateSatPerVb, ')
          ..write('createdAt: $createdAt, ')
          ..write('expireAfterSec: $expireAfterSec, ')
          ..write('originalTxBytes: $originalTxBytes, ')
          ..write('originalTxId: $originalTxId, ')
          ..write('amountSat: $amountSat, ')
          ..write('proposalPsbt: $proposalPsbt, ')
          ..write('txId: $txId, ')
          ..write('isExpired: $isExpired, ')
          ..write('isCompleted: $isCompleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    address,
    isTestnet,
    receiver,
    walletId,
    pjUri,
    maxFeeRateSatPerVb,
    createdAt,
    expireAfterSec,
    $driftBlobEquality.hash(originalTxBytes),
    originalTxId,
    amountSat,
    proposalPsbt,
    txId,
    isExpired,
    isCompleted,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PayjoinReceiversData &&
          other.id == this.id &&
          other.address == this.address &&
          other.isTestnet == this.isTestnet &&
          other.receiver == this.receiver &&
          other.walletId == this.walletId &&
          other.pjUri == this.pjUri &&
          other.maxFeeRateSatPerVb == this.maxFeeRateSatPerVb &&
          other.createdAt == this.createdAt &&
          other.expireAfterSec == this.expireAfterSec &&
          $driftBlobEquality.equals(
            other.originalTxBytes,
            this.originalTxBytes,
          ) &&
          other.originalTxId == this.originalTxId &&
          other.amountSat == this.amountSat &&
          other.proposalPsbt == this.proposalPsbt &&
          other.txId == this.txId &&
          other.isExpired == this.isExpired &&
          other.isCompleted == this.isCompleted);
}

class PayjoinReceiversCompanion extends UpdateCompanion<PayjoinReceiversData> {
  final Value<String> id;
  final Value<String> address;
  final Value<int> isTestnet;
  final Value<String> receiver;
  final Value<String> walletId;
  final Value<String> pjUri;
  final Value<int> maxFeeRateSatPerVb;
  final Value<int> createdAt;
  final Value<int> expireAfterSec;
  final Value<i2.Uint8List?> originalTxBytes;
  final Value<String?> originalTxId;
  final Value<int?> amountSat;
  final Value<String?> proposalPsbt;
  final Value<String?> txId;
  final Value<int> isExpired;
  final Value<int> isCompleted;
  final Value<int> rowid;
  const PayjoinReceiversCompanion({
    this.id = const Value.absent(),
    this.address = const Value.absent(),
    this.isTestnet = const Value.absent(),
    this.receiver = const Value.absent(),
    this.walletId = const Value.absent(),
    this.pjUri = const Value.absent(),
    this.maxFeeRateSatPerVb = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.expireAfterSec = const Value.absent(),
    this.originalTxBytes = const Value.absent(),
    this.originalTxId = const Value.absent(),
    this.amountSat = const Value.absent(),
    this.proposalPsbt = const Value.absent(),
    this.txId = const Value.absent(),
    this.isExpired = const Value.absent(),
    this.isCompleted = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PayjoinReceiversCompanion.insert({
    required String id,
    required String address,
    required int isTestnet,
    required String receiver,
    required String walletId,
    required String pjUri,
    required int maxFeeRateSatPerVb,
    required int createdAt,
    required int expireAfterSec,
    this.originalTxBytes = const Value.absent(),
    this.originalTxId = const Value.absent(),
    this.amountSat = const Value.absent(),
    this.proposalPsbt = const Value.absent(),
    this.txId = const Value.absent(),
    required int isExpired,
    required int isCompleted,
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       address = Value(address),
       isTestnet = Value(isTestnet),
       receiver = Value(receiver),
       walletId = Value(walletId),
       pjUri = Value(pjUri),
       maxFeeRateSatPerVb = Value(maxFeeRateSatPerVb),
       createdAt = Value(createdAt),
       expireAfterSec = Value(expireAfterSec),
       isExpired = Value(isExpired),
       isCompleted = Value(isCompleted);
  static Insertable<PayjoinReceiversData> custom({
    Expression<String>? id,
    Expression<String>? address,
    Expression<int>? isTestnet,
    Expression<String>? receiver,
    Expression<String>? walletId,
    Expression<String>? pjUri,
    Expression<int>? maxFeeRateSatPerVb,
    Expression<int>? createdAt,
    Expression<int>? expireAfterSec,
    Expression<i2.Uint8List>? originalTxBytes,
    Expression<String>? originalTxId,
    Expression<int>? amountSat,
    Expression<String>? proposalPsbt,
    Expression<String>? txId,
    Expression<int>? isExpired,
    Expression<int>? isCompleted,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (address != null) 'address': address,
      if (isTestnet != null) 'is_testnet': isTestnet,
      if (receiver != null) 'receiver': receiver,
      if (walletId != null) 'wallet_id': walletId,
      if (pjUri != null) 'pj_uri': pjUri,
      if (maxFeeRateSatPerVb != null)
        'max_fee_rate_sat_per_vb': maxFeeRateSatPerVb,
      if (createdAt != null) 'created_at': createdAt,
      if (expireAfterSec != null) 'expire_after_sec': expireAfterSec,
      if (originalTxBytes != null) 'original_tx_bytes': originalTxBytes,
      if (originalTxId != null) 'original_tx_id': originalTxId,
      if (amountSat != null) 'amount_sat': amountSat,
      if (proposalPsbt != null) 'proposal_psbt': proposalPsbt,
      if (txId != null) 'tx_id': txId,
      if (isExpired != null) 'is_expired': isExpired,
      if (isCompleted != null) 'is_completed': isCompleted,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PayjoinReceiversCompanion copyWith({
    Value<String>? id,
    Value<String>? address,
    Value<int>? isTestnet,
    Value<String>? receiver,
    Value<String>? walletId,
    Value<String>? pjUri,
    Value<int>? maxFeeRateSatPerVb,
    Value<int>? createdAt,
    Value<int>? expireAfterSec,
    Value<i2.Uint8List?>? originalTxBytes,
    Value<String?>? originalTxId,
    Value<int?>? amountSat,
    Value<String?>? proposalPsbt,
    Value<String?>? txId,
    Value<int>? isExpired,
    Value<int>? isCompleted,
    Value<int>? rowid,
  }) {
    return PayjoinReceiversCompanion(
      id: id ?? this.id,
      address: address ?? this.address,
      isTestnet: isTestnet ?? this.isTestnet,
      receiver: receiver ?? this.receiver,
      walletId: walletId ?? this.walletId,
      pjUri: pjUri ?? this.pjUri,
      maxFeeRateSatPerVb: maxFeeRateSatPerVb ?? this.maxFeeRateSatPerVb,
      createdAt: createdAt ?? this.createdAt,
      expireAfterSec: expireAfterSec ?? this.expireAfterSec,
      originalTxBytes: originalTxBytes ?? this.originalTxBytes,
      originalTxId: originalTxId ?? this.originalTxId,
      amountSat: amountSat ?? this.amountSat,
      proposalPsbt: proposalPsbt ?? this.proposalPsbt,
      txId: txId ?? this.txId,
      isExpired: isExpired ?? this.isExpired,
      isCompleted: isCompleted ?? this.isCompleted,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (isTestnet.present) {
      map['is_testnet'] = Variable<int>(isTestnet.value);
    }
    if (receiver.present) {
      map['receiver'] = Variable<String>(receiver.value);
    }
    if (walletId.present) {
      map['wallet_id'] = Variable<String>(walletId.value);
    }
    if (pjUri.present) {
      map['pj_uri'] = Variable<String>(pjUri.value);
    }
    if (maxFeeRateSatPerVb.present) {
      map['max_fee_rate_sat_per_vb'] = Variable<int>(maxFeeRateSatPerVb.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (expireAfterSec.present) {
      map['expire_after_sec'] = Variable<int>(expireAfterSec.value);
    }
    if (originalTxBytes.present) {
      map['original_tx_bytes'] = Variable<i2.Uint8List>(originalTxBytes.value);
    }
    if (originalTxId.present) {
      map['original_tx_id'] = Variable<String>(originalTxId.value);
    }
    if (amountSat.present) {
      map['amount_sat'] = Variable<int>(amountSat.value);
    }
    if (proposalPsbt.present) {
      map['proposal_psbt'] = Variable<String>(proposalPsbt.value);
    }
    if (txId.present) {
      map['tx_id'] = Variable<String>(txId.value);
    }
    if (isExpired.present) {
      map['is_expired'] = Variable<int>(isExpired.value);
    }
    if (isCompleted.present) {
      map['is_completed'] = Variable<int>(isCompleted.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PayjoinReceiversCompanion(')
          ..write('id: $id, ')
          ..write('address: $address, ')
          ..write('isTestnet: $isTestnet, ')
          ..write('receiver: $receiver, ')
          ..write('walletId: $walletId, ')
          ..write('pjUri: $pjUri, ')
          ..write('maxFeeRateSatPerVb: $maxFeeRateSatPerVb, ')
          ..write('createdAt: $createdAt, ')
          ..write('expireAfterSec: $expireAfterSec, ')
          ..write('originalTxBytes: $originalTxBytes, ')
          ..write('originalTxId: $originalTxId, ')
          ..write('amountSat: $amountSat, ')
          ..write('proposalPsbt: $proposalPsbt, ')
          ..write('txId: $txId, ')
          ..write('isExpired: $isExpired, ')
          ..write('isCompleted: $isCompleted, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class ElectrumServers extends Table
    with TableInfo<ElectrumServers, ElectrumServersData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  ElectrumServers(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<String> url = GeneratedColumn<String>(
    'url',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> isTestnet = GeneratedColumn<int>(
    'is_testnet',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_testnet IN (0, 1))',
  );
  late final GeneratedColumn<int> isLiquid = GeneratedColumn<int>(
    'is_liquid',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_liquid IN (0, 1))',
  );
  late final GeneratedColumn<int> priority = GeneratedColumn<int>(
    'priority',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> isCustom = GeneratedColumn<int>(
    'is_custom',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_custom IN (0, 1))',
  );
  @override
  List<GeneratedColumn> get $columns => [
    url,
    isTestnet,
    isLiquid,
    priority,
    isCustom,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'electrum_servers';
  @override
  Set<GeneratedColumn> get $primaryKey => {url};
  @override
  ElectrumServersData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ElectrumServersData(
      url: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}url'],
      )!,
      isTestnet: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_testnet'],
      )!,
      isLiquid: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_liquid'],
      )!,
      priority: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}priority'],
      )!,
      isCustom: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_custom'],
      )!,
    );
  }

  @override
  ElectrumServers createAlias(String alias) {
    return ElectrumServers(attachedDatabase, alias);
  }

  @override
  List<String> get customConstraints => const ['PRIMARY KEY(url)'];
  @override
  bool get dontWriteConstraints => true;
}

class ElectrumServersData extends DataClass
    implements Insertable<ElectrumServersData> {
  final String url;
  final int isTestnet;
  final int isLiquid;
  final int priority;
  final int isCustom;
  const ElectrumServersData({
    required this.url,
    required this.isTestnet,
    required this.isLiquid,
    required this.priority,
    required this.isCustom,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['url'] = Variable<String>(url);
    map['is_testnet'] = Variable<int>(isTestnet);
    map['is_liquid'] = Variable<int>(isLiquid);
    map['priority'] = Variable<int>(priority);
    map['is_custom'] = Variable<int>(isCustom);
    return map;
  }

  ElectrumServersCompanion toCompanion(bool nullToAbsent) {
    return ElectrumServersCompanion(
      url: Value(url),
      isTestnet: Value(isTestnet),
      isLiquid: Value(isLiquid),
      priority: Value(priority),
      isCustom: Value(isCustom),
    );
  }

  factory ElectrumServersData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ElectrumServersData(
      url: serializer.fromJson<String>(json['url']),
      isTestnet: serializer.fromJson<int>(json['isTestnet']),
      isLiquid: serializer.fromJson<int>(json['isLiquid']),
      priority: serializer.fromJson<int>(json['priority']),
      isCustom: serializer.fromJson<int>(json['isCustom']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'url': serializer.toJson<String>(url),
      'isTestnet': serializer.toJson<int>(isTestnet),
      'isLiquid': serializer.toJson<int>(isLiquid),
      'priority': serializer.toJson<int>(priority),
      'isCustom': serializer.toJson<int>(isCustom),
    };
  }

  ElectrumServersData copyWith({
    String? url,
    int? isTestnet,
    int? isLiquid,
    int? priority,
    int? isCustom,
  }) => ElectrumServersData(
    url: url ?? this.url,
    isTestnet: isTestnet ?? this.isTestnet,
    isLiquid: isLiquid ?? this.isLiquid,
    priority: priority ?? this.priority,
    isCustom: isCustom ?? this.isCustom,
  );
  ElectrumServersData copyWithCompanion(ElectrumServersCompanion data) {
    return ElectrumServersData(
      url: data.url.present ? data.url.value : this.url,
      isTestnet: data.isTestnet.present ? data.isTestnet.value : this.isTestnet,
      isLiquid: data.isLiquid.present ? data.isLiquid.value : this.isLiquid,
      priority: data.priority.present ? data.priority.value : this.priority,
      isCustom: data.isCustom.present ? data.isCustom.value : this.isCustom,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ElectrumServersData(')
          ..write('url: $url, ')
          ..write('isTestnet: $isTestnet, ')
          ..write('isLiquid: $isLiquid, ')
          ..write('priority: $priority, ')
          ..write('isCustom: $isCustom')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(url, isTestnet, isLiquid, priority, isCustom);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ElectrumServersData &&
          other.url == this.url &&
          other.isTestnet == this.isTestnet &&
          other.isLiquid == this.isLiquid &&
          other.priority == this.priority &&
          other.isCustom == this.isCustom);
}

class ElectrumServersCompanion extends UpdateCompanion<ElectrumServersData> {
  final Value<String> url;
  final Value<int> isTestnet;
  final Value<int> isLiquid;
  final Value<int> priority;
  final Value<int> isCustom;
  final Value<int> rowid;
  const ElectrumServersCompanion({
    this.url = const Value.absent(),
    this.isTestnet = const Value.absent(),
    this.isLiquid = const Value.absent(),
    this.priority = const Value.absent(),
    this.isCustom = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ElectrumServersCompanion.insert({
    required String url,
    required int isTestnet,
    required int isLiquid,
    required int priority,
    required int isCustom,
    this.rowid = const Value.absent(),
  }) : url = Value(url),
       isTestnet = Value(isTestnet),
       isLiquid = Value(isLiquid),
       priority = Value(priority),
       isCustom = Value(isCustom);
  static Insertable<ElectrumServersData> custom({
    Expression<String>? url,
    Expression<int>? isTestnet,
    Expression<int>? isLiquid,
    Expression<int>? priority,
    Expression<int>? isCustom,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (url != null) 'url': url,
      if (isTestnet != null) 'is_testnet': isTestnet,
      if (isLiquid != null) 'is_liquid': isLiquid,
      if (priority != null) 'priority': priority,
      if (isCustom != null) 'is_custom': isCustom,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ElectrumServersCompanion copyWith({
    Value<String>? url,
    Value<int>? isTestnet,
    Value<int>? isLiquid,
    Value<int>? priority,
    Value<int>? isCustom,
    Value<int>? rowid,
  }) {
    return ElectrumServersCompanion(
      url: url ?? this.url,
      isTestnet: isTestnet ?? this.isTestnet,
      isLiquid: isLiquid ?? this.isLiquid,
      priority: priority ?? this.priority,
      isCustom: isCustom ?? this.isCustom,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (url.present) {
      map['url'] = Variable<String>(url.value);
    }
    if (isTestnet.present) {
      map['is_testnet'] = Variable<int>(isTestnet.value);
    }
    if (isLiquid.present) {
      map['is_liquid'] = Variable<int>(isLiquid.value);
    }
    if (priority.present) {
      map['priority'] = Variable<int>(priority.value);
    }
    if (isCustom.present) {
      map['is_custom'] = Variable<int>(isCustom.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ElectrumServersCompanion(')
          ..write('url: $url, ')
          ..write('isTestnet: $isTestnet, ')
          ..write('isLiquid: $isLiquid, ')
          ..write('priority: $priority, ')
          ..write('isCustom: $isCustom, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class ElectrumSettings extends Table
    with TableInfo<ElectrumSettings, ElectrumSettingsData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  ElectrumSettings(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<String> network = GeneratedColumn<String>(
    'network',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> validateDomain = GeneratedColumn<int>(
    'validate_domain',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (validate_domain IN (0, 1))',
  );
  late final GeneratedColumn<int> stopGap = GeneratedColumn<int>(
    'stop_gap',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> timeout = GeneratedColumn<int>(
    'timeout',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> retry = GeneratedColumn<int>(
    'retry',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> socks5 = GeneratedColumn<String>(
    'socks5',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  @override
  List<GeneratedColumn> get $columns => [
    network,
    validateDomain,
    stopGap,
    timeout,
    retry,
    socks5,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'electrum_settings';
  @override
  Set<GeneratedColumn> get $primaryKey => {network};
  @override
  ElectrumSettingsData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ElectrumSettingsData(
      network: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}network'],
      )!,
      validateDomain: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}validate_domain'],
      )!,
      stopGap: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}stop_gap'],
      )!,
      timeout: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}timeout'],
      )!,
      retry: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}retry'],
      )!,
      socks5: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}socks5'],
      ),
    );
  }

  @override
  ElectrumSettings createAlias(String alias) {
    return ElectrumSettings(attachedDatabase, alias);
  }

  @override
  List<String> get customConstraints => const ['PRIMARY KEY(network)'];
  @override
  bool get dontWriteConstraints => true;
}

class ElectrumSettingsData extends DataClass
    implements Insertable<ElectrumSettingsData> {
  final String network;
  final int validateDomain;
  final int stopGap;
  final int timeout;
  final int retry;
  final String? socks5;
  const ElectrumSettingsData({
    required this.network,
    required this.validateDomain,
    required this.stopGap,
    required this.timeout,
    required this.retry,
    this.socks5,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['network'] = Variable<String>(network);
    map['validate_domain'] = Variable<int>(validateDomain);
    map['stop_gap'] = Variable<int>(stopGap);
    map['timeout'] = Variable<int>(timeout);
    map['retry'] = Variable<int>(retry);
    if (!nullToAbsent || socks5 != null) {
      map['socks5'] = Variable<String>(socks5);
    }
    return map;
  }

  ElectrumSettingsCompanion toCompanion(bool nullToAbsent) {
    return ElectrumSettingsCompanion(
      network: Value(network),
      validateDomain: Value(validateDomain),
      stopGap: Value(stopGap),
      timeout: Value(timeout),
      retry: Value(retry),
      socks5: socks5 == null && nullToAbsent
          ? const Value.absent()
          : Value(socks5),
    );
  }

  factory ElectrumSettingsData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ElectrumSettingsData(
      network: serializer.fromJson<String>(json['network']),
      validateDomain: serializer.fromJson<int>(json['validateDomain']),
      stopGap: serializer.fromJson<int>(json['stopGap']),
      timeout: serializer.fromJson<int>(json['timeout']),
      retry: serializer.fromJson<int>(json['retry']),
      socks5: serializer.fromJson<String?>(json['socks5']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'network': serializer.toJson<String>(network),
      'validateDomain': serializer.toJson<int>(validateDomain),
      'stopGap': serializer.toJson<int>(stopGap),
      'timeout': serializer.toJson<int>(timeout),
      'retry': serializer.toJson<int>(retry),
      'socks5': serializer.toJson<String?>(socks5),
    };
  }

  ElectrumSettingsData copyWith({
    String? network,
    int? validateDomain,
    int? stopGap,
    int? timeout,
    int? retry,
    Value<String?> socks5 = const Value.absent(),
  }) => ElectrumSettingsData(
    network: network ?? this.network,
    validateDomain: validateDomain ?? this.validateDomain,
    stopGap: stopGap ?? this.stopGap,
    timeout: timeout ?? this.timeout,
    retry: retry ?? this.retry,
    socks5: socks5.present ? socks5.value : this.socks5,
  );
  ElectrumSettingsData copyWithCompanion(ElectrumSettingsCompanion data) {
    return ElectrumSettingsData(
      network: data.network.present ? data.network.value : this.network,
      validateDomain: data.validateDomain.present
          ? data.validateDomain.value
          : this.validateDomain,
      stopGap: data.stopGap.present ? data.stopGap.value : this.stopGap,
      timeout: data.timeout.present ? data.timeout.value : this.timeout,
      retry: data.retry.present ? data.retry.value : this.retry,
      socks5: data.socks5.present ? data.socks5.value : this.socks5,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ElectrumSettingsData(')
          ..write('network: $network, ')
          ..write('validateDomain: $validateDomain, ')
          ..write('stopGap: $stopGap, ')
          ..write('timeout: $timeout, ')
          ..write('retry: $retry, ')
          ..write('socks5: $socks5')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(network, validateDomain, stopGap, timeout, retry, socks5);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ElectrumSettingsData &&
          other.network == this.network &&
          other.validateDomain == this.validateDomain &&
          other.stopGap == this.stopGap &&
          other.timeout == this.timeout &&
          other.retry == this.retry &&
          other.socks5 == this.socks5);
}

class ElectrumSettingsCompanion extends UpdateCompanion<ElectrumSettingsData> {
  final Value<String> network;
  final Value<int> validateDomain;
  final Value<int> stopGap;
  final Value<int> timeout;
  final Value<int> retry;
  final Value<String?> socks5;
  final Value<int> rowid;
  const ElectrumSettingsCompanion({
    this.network = const Value.absent(),
    this.validateDomain = const Value.absent(),
    this.stopGap = const Value.absent(),
    this.timeout = const Value.absent(),
    this.retry = const Value.absent(),
    this.socks5 = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ElectrumSettingsCompanion.insert({
    required String network,
    required int validateDomain,
    required int stopGap,
    required int timeout,
    required int retry,
    this.socks5 = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : network = Value(network),
       validateDomain = Value(validateDomain),
       stopGap = Value(stopGap),
       timeout = Value(timeout),
       retry = Value(retry);
  static Insertable<ElectrumSettingsData> custom({
    Expression<String>? network,
    Expression<int>? validateDomain,
    Expression<int>? stopGap,
    Expression<int>? timeout,
    Expression<int>? retry,
    Expression<String>? socks5,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (network != null) 'network': network,
      if (validateDomain != null) 'validate_domain': validateDomain,
      if (stopGap != null) 'stop_gap': stopGap,
      if (timeout != null) 'timeout': timeout,
      if (retry != null) 'retry': retry,
      if (socks5 != null) 'socks5': socks5,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ElectrumSettingsCompanion copyWith({
    Value<String>? network,
    Value<int>? validateDomain,
    Value<int>? stopGap,
    Value<int>? timeout,
    Value<int>? retry,
    Value<String?>? socks5,
    Value<int>? rowid,
  }) {
    return ElectrumSettingsCompanion(
      network: network ?? this.network,
      validateDomain: validateDomain ?? this.validateDomain,
      stopGap: stopGap ?? this.stopGap,
      timeout: timeout ?? this.timeout,
      retry: retry ?? this.retry,
      socks5: socks5 ?? this.socks5,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (network.present) {
      map['network'] = Variable<String>(network.value);
    }
    if (validateDomain.present) {
      map['validate_domain'] = Variable<int>(validateDomain.value);
    }
    if (stopGap.present) {
      map['stop_gap'] = Variable<int>(stopGap.value);
    }
    if (timeout.present) {
      map['timeout'] = Variable<int>(timeout.value);
    }
    if (retry.present) {
      map['retry'] = Variable<int>(retry.value);
    }
    if (socks5.present) {
      map['socks5'] = Variable<String>(socks5.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ElectrumSettingsCompanion(')
          ..write('network: $network, ')
          ..write('validateDomain: $validateDomain, ')
          ..write('stopGap: $stopGap, ')
          ..write('timeout: $timeout, ')
          ..write('retry: $retry, ')
          ..write('socks5: $socks5, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class MempoolServers extends Table
    with TableInfo<MempoolServers, MempoolServersData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  MempoolServers(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<String> url = GeneratedColumn<String>(
    'url',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> isTestnet = GeneratedColumn<int>(
    'is_testnet',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_testnet IN (0, 1))',
  );
  late final GeneratedColumn<int> isLiquid = GeneratedColumn<int>(
    'is_liquid',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_liquid IN (0, 1))',
  );
  late final GeneratedColumn<int> isCustom = GeneratedColumn<int>(
    'is_custom',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_custom IN (0, 1))',
  );
  late final GeneratedColumn<int> enableSsl = GeneratedColumn<int>(
    'enable_ssl',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL DEFAULT 1 CHECK (enable_ssl IN (0, 1))',
    defaultValue: const CustomExpression('1'),
  );
  @override
  List<GeneratedColumn> get $columns => [
    url,
    isTestnet,
    isLiquid,
    isCustom,
    enableSsl,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'mempool_servers';
  @override
  Set<GeneratedColumn> get $primaryKey => {url, isTestnet, isLiquid};
  @override
  MempoolServersData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MempoolServersData(
      url: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}url'],
      )!,
      isTestnet: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_testnet'],
      )!,
      isLiquid: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_liquid'],
      )!,
      isCustom: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_custom'],
      )!,
      enableSsl: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}enable_ssl'],
      )!,
    );
  }

  @override
  MempoolServers createAlias(String alias) {
    return MempoolServers(attachedDatabase, alias);
  }

  @override
  List<String> get customConstraints => const [
    'PRIMARY KEY(url, is_testnet, is_liquid)',
  ];
  @override
  bool get dontWriteConstraints => true;
}

class MempoolServersData extends DataClass
    implements Insertable<MempoolServersData> {
  final String url;
  final int isTestnet;
  final int isLiquid;
  final int isCustom;
  final int enableSsl;
  const MempoolServersData({
    required this.url,
    required this.isTestnet,
    required this.isLiquid,
    required this.isCustom,
    required this.enableSsl,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['url'] = Variable<String>(url);
    map['is_testnet'] = Variable<int>(isTestnet);
    map['is_liquid'] = Variable<int>(isLiquid);
    map['is_custom'] = Variable<int>(isCustom);
    map['enable_ssl'] = Variable<int>(enableSsl);
    return map;
  }

  MempoolServersCompanion toCompanion(bool nullToAbsent) {
    return MempoolServersCompanion(
      url: Value(url),
      isTestnet: Value(isTestnet),
      isLiquid: Value(isLiquid),
      isCustom: Value(isCustom),
      enableSsl: Value(enableSsl),
    );
  }

  factory MempoolServersData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MempoolServersData(
      url: serializer.fromJson<String>(json['url']),
      isTestnet: serializer.fromJson<int>(json['isTestnet']),
      isLiquid: serializer.fromJson<int>(json['isLiquid']),
      isCustom: serializer.fromJson<int>(json['isCustom']),
      enableSsl: serializer.fromJson<int>(json['enableSsl']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'url': serializer.toJson<String>(url),
      'isTestnet': serializer.toJson<int>(isTestnet),
      'isLiquid': serializer.toJson<int>(isLiquid),
      'isCustom': serializer.toJson<int>(isCustom),
      'enableSsl': serializer.toJson<int>(enableSsl),
    };
  }

  MempoolServersData copyWith({
    String? url,
    int? isTestnet,
    int? isLiquid,
    int? isCustom,
    int? enableSsl,
  }) => MempoolServersData(
    url: url ?? this.url,
    isTestnet: isTestnet ?? this.isTestnet,
    isLiquid: isLiquid ?? this.isLiquid,
    isCustom: isCustom ?? this.isCustom,
    enableSsl: enableSsl ?? this.enableSsl,
  );
  MempoolServersData copyWithCompanion(MempoolServersCompanion data) {
    return MempoolServersData(
      url: data.url.present ? data.url.value : this.url,
      isTestnet: data.isTestnet.present ? data.isTestnet.value : this.isTestnet,
      isLiquid: data.isLiquid.present ? data.isLiquid.value : this.isLiquid,
      isCustom: data.isCustom.present ? data.isCustom.value : this.isCustom,
      enableSsl: data.enableSsl.present ? data.enableSsl.value : this.enableSsl,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MempoolServersData(')
          ..write('url: $url, ')
          ..write('isTestnet: $isTestnet, ')
          ..write('isLiquid: $isLiquid, ')
          ..write('isCustom: $isCustom, ')
          ..write('enableSsl: $enableSsl')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(url, isTestnet, isLiquid, isCustom, enableSsl);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MempoolServersData &&
          other.url == this.url &&
          other.isTestnet == this.isTestnet &&
          other.isLiquid == this.isLiquid &&
          other.isCustom == this.isCustom &&
          other.enableSsl == this.enableSsl);
}

class MempoolServersCompanion extends UpdateCompanion<MempoolServersData> {
  final Value<String> url;
  final Value<int> isTestnet;
  final Value<int> isLiquid;
  final Value<int> isCustom;
  final Value<int> enableSsl;
  final Value<int> rowid;
  const MempoolServersCompanion({
    this.url = const Value.absent(),
    this.isTestnet = const Value.absent(),
    this.isLiquid = const Value.absent(),
    this.isCustom = const Value.absent(),
    this.enableSsl = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MempoolServersCompanion.insert({
    required String url,
    required int isTestnet,
    required int isLiquid,
    required int isCustom,
    this.enableSsl = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : url = Value(url),
       isTestnet = Value(isTestnet),
       isLiquid = Value(isLiquid),
       isCustom = Value(isCustom);
  static Insertable<MempoolServersData> custom({
    Expression<String>? url,
    Expression<int>? isTestnet,
    Expression<int>? isLiquid,
    Expression<int>? isCustom,
    Expression<int>? enableSsl,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (url != null) 'url': url,
      if (isTestnet != null) 'is_testnet': isTestnet,
      if (isLiquid != null) 'is_liquid': isLiquid,
      if (isCustom != null) 'is_custom': isCustom,
      if (enableSsl != null) 'enable_ssl': enableSsl,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MempoolServersCompanion copyWith({
    Value<String>? url,
    Value<int>? isTestnet,
    Value<int>? isLiquid,
    Value<int>? isCustom,
    Value<int>? enableSsl,
    Value<int>? rowid,
  }) {
    return MempoolServersCompanion(
      url: url ?? this.url,
      isTestnet: isTestnet ?? this.isTestnet,
      isLiquid: isLiquid ?? this.isLiquid,
      isCustom: isCustom ?? this.isCustom,
      enableSsl: enableSsl ?? this.enableSsl,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (url.present) {
      map['url'] = Variable<String>(url.value);
    }
    if (isTestnet.present) {
      map['is_testnet'] = Variable<int>(isTestnet.value);
    }
    if (isLiquid.present) {
      map['is_liquid'] = Variable<int>(isLiquid.value);
    }
    if (isCustom.present) {
      map['is_custom'] = Variable<int>(isCustom.value);
    }
    if (enableSsl.present) {
      map['enable_ssl'] = Variable<int>(enableSsl.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MempoolServersCompanion(')
          ..write('url: $url, ')
          ..write('isTestnet: $isTestnet, ')
          ..write('isLiquid: $isLiquid, ')
          ..write('isCustom: $isCustom, ')
          ..write('enableSsl: $enableSsl, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class MempoolSettings extends Table
    with TableInfo<MempoolSettings, MempoolSettingsData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  MempoolSettings(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<String> network = GeneratedColumn<String>(
    'network',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> useForFeeEstimation = GeneratedColumn<int>(
    'use_for_fee_estimation',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints:
        'NOT NULL DEFAULT 1 CHECK (use_for_fee_estimation IN (0, 1))',
    defaultValue: const CustomExpression('1'),
  );
  @override
  List<GeneratedColumn> get $columns => [network, useForFeeEstimation];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'mempool_settings';
  @override
  Set<GeneratedColumn> get $primaryKey => {network};
  @override
  MempoolSettingsData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MempoolSettingsData(
      network: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}network'],
      )!,
      useForFeeEstimation: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}use_for_fee_estimation'],
      )!,
    );
  }

  @override
  MempoolSettings createAlias(String alias) {
    return MempoolSettings(attachedDatabase, alias);
  }

  @override
  List<String> get customConstraints => const ['PRIMARY KEY(network)'];
  @override
  bool get dontWriteConstraints => true;
}

class MempoolSettingsData extends DataClass
    implements Insertable<MempoolSettingsData> {
  final String network;
  final int useForFeeEstimation;
  const MempoolSettingsData({
    required this.network,
    required this.useForFeeEstimation,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['network'] = Variable<String>(network);
    map['use_for_fee_estimation'] = Variable<int>(useForFeeEstimation);
    return map;
  }

  MempoolSettingsCompanion toCompanion(bool nullToAbsent) {
    return MempoolSettingsCompanion(
      network: Value(network),
      useForFeeEstimation: Value(useForFeeEstimation),
    );
  }

  factory MempoolSettingsData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MempoolSettingsData(
      network: serializer.fromJson<String>(json['network']),
      useForFeeEstimation: serializer.fromJson<int>(
        json['useForFeeEstimation'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'network': serializer.toJson<String>(network),
      'useForFeeEstimation': serializer.toJson<int>(useForFeeEstimation),
    };
  }

  MempoolSettingsData copyWith({String? network, int? useForFeeEstimation}) =>
      MempoolSettingsData(
        network: network ?? this.network,
        useForFeeEstimation: useForFeeEstimation ?? this.useForFeeEstimation,
      );
  MempoolSettingsData copyWithCompanion(MempoolSettingsCompanion data) {
    return MempoolSettingsData(
      network: data.network.present ? data.network.value : this.network,
      useForFeeEstimation: data.useForFeeEstimation.present
          ? data.useForFeeEstimation.value
          : this.useForFeeEstimation,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MempoolSettingsData(')
          ..write('network: $network, ')
          ..write('useForFeeEstimation: $useForFeeEstimation')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(network, useForFeeEstimation);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MempoolSettingsData &&
          other.network == this.network &&
          other.useForFeeEstimation == this.useForFeeEstimation);
}

class MempoolSettingsCompanion extends UpdateCompanion<MempoolSettingsData> {
  final Value<String> network;
  final Value<int> useForFeeEstimation;
  final Value<int> rowid;
  const MempoolSettingsCompanion({
    this.network = const Value.absent(),
    this.useForFeeEstimation = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MempoolSettingsCompanion.insert({
    required String network,
    this.useForFeeEstimation = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : network = Value(network);
  static Insertable<MempoolSettingsData> custom({
    Expression<String>? network,
    Expression<int>? useForFeeEstimation,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (network != null) 'network': network,
      if (useForFeeEstimation != null)
        'use_for_fee_estimation': useForFeeEstimation,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MempoolSettingsCompanion copyWith({
    Value<String>? network,
    Value<int>? useForFeeEstimation,
    Value<int>? rowid,
  }) {
    return MempoolSettingsCompanion(
      network: network ?? this.network,
      useForFeeEstimation: useForFeeEstimation ?? this.useForFeeEstimation,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (network.present) {
      map['network'] = Variable<String>(network.value);
    }
    if (useForFeeEstimation.present) {
      map['use_for_fee_estimation'] = Variable<int>(useForFeeEstimation.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MempoolSettingsCompanion(')
          ..write('network: $network, ')
          ..write('useForFeeEstimation: $useForFeeEstimation, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class Swaps extends Table with TableInfo<Swaps, SwapsData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Swaps(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> direction = GeneratedColumn<String>(
    'direction',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> isTestnet = GeneratedColumn<int>(
    'is_testnet',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_testnet IN (0, 1))',
  );
  late final GeneratedColumn<int> keyIndex = GeneratedColumn<int>(
    'key_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> creationTime = GeneratedColumn<int>(
    'creation_time',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> completionTime = GeneratedColumn<int>(
    'completion_time',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> receiveWalletId = GeneratedColumn<String>(
    'receive_wallet_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> sendWalletId = GeneratedColumn<String>(
    'send_wallet_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> invoice = GeneratedColumn<String>(
    'invoice',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> paymentAddress = GeneratedColumn<String>(
    'payment_address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<int> paymentAmount = GeneratedColumn<int>(
    'payment_amount',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> receiveAddress = GeneratedColumn<String>(
    'receive_address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> receiveTxid = GeneratedColumn<String>(
    'receive_txid',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> sendTxid = GeneratedColumn<String>(
    'send_txid',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> preimage = GeneratedColumn<String>(
    'preimage',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> refundAddress = GeneratedColumn<String>(
    'refund_address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> refundTxid = GeneratedColumn<String>(
    'refund_txid',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<int> boltzFees = GeneratedColumn<int>(
    'boltz_fees',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<int> lockupFees = GeneratedColumn<int>(
    'lockup_fees',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<int> claimFees = GeneratedColumn<int>(
    'claim_fees',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<int> serverNetworkFees = GeneratedColumn<int>(
    'server_network_fees',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    type,
    direction,
    status,
    isTestnet,
    keyIndex,
    creationTime,
    completionTime,
    receiveWalletId,
    sendWalletId,
    invoice,
    paymentAddress,
    paymentAmount,
    receiveAddress,
    receiveTxid,
    sendTxid,
    preimage,
    refundAddress,
    refundTxid,
    boltzFees,
    lockupFees,
    claimFees,
    serverNetworkFees,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'swaps';
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SwapsData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SwapsData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      )!,
      direction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}direction'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      isTestnet: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_testnet'],
      )!,
      keyIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}key_index'],
      )!,
      creationTime: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}creation_time'],
      )!,
      completionTime: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}completion_time'],
      ),
      receiveWalletId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}receive_wallet_id'],
      ),
      sendWalletId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}send_wallet_id'],
      ),
      invoice: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}invoice'],
      ),
      paymentAddress: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payment_address'],
      ),
      paymentAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}payment_amount'],
      ),
      receiveAddress: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}receive_address'],
      ),
      receiveTxid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}receive_txid'],
      ),
      sendTxid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}send_txid'],
      ),
      preimage: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}preimage'],
      ),
      refundAddress: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}refund_address'],
      ),
      refundTxid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}refund_txid'],
      ),
      boltzFees: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}boltz_fees'],
      ),
      lockupFees: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lockup_fees'],
      ),
      claimFees: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}claim_fees'],
      ),
      serverNetworkFees: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}server_network_fees'],
      ),
    );
  }

  @override
  Swaps createAlias(String alias) {
    return Swaps(attachedDatabase, alias);
  }

  @override
  List<String> get customConstraints => const ['PRIMARY KEY(id)'];
  @override
  bool get dontWriteConstraints => true;
}

class SwapsData extends DataClass implements Insertable<SwapsData> {
  final String id;
  final String type;
  final String direction;
  final String status;
  final int isTestnet;
  final int keyIndex;
  final int creationTime;
  final int? completionTime;
  final String? receiveWalletId;
  final String? sendWalletId;
  final String? invoice;
  final String? paymentAddress;
  final int? paymentAmount;
  final String? receiveAddress;
  final String? receiveTxid;
  final String? sendTxid;
  final String? preimage;
  final String? refundAddress;
  final String? refundTxid;
  final int? boltzFees;
  final int? lockupFees;
  final int? claimFees;
  final int? serverNetworkFees;
  const SwapsData({
    required this.id,
    required this.type,
    required this.direction,
    required this.status,
    required this.isTestnet,
    required this.keyIndex,
    required this.creationTime,
    this.completionTime,
    this.receiveWalletId,
    this.sendWalletId,
    this.invoice,
    this.paymentAddress,
    this.paymentAmount,
    this.receiveAddress,
    this.receiveTxid,
    this.sendTxid,
    this.preimage,
    this.refundAddress,
    this.refundTxid,
    this.boltzFees,
    this.lockupFees,
    this.claimFees,
    this.serverNetworkFees,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['type'] = Variable<String>(type);
    map['direction'] = Variable<String>(direction);
    map['status'] = Variable<String>(status);
    map['is_testnet'] = Variable<int>(isTestnet);
    map['key_index'] = Variable<int>(keyIndex);
    map['creation_time'] = Variable<int>(creationTime);
    if (!nullToAbsent || completionTime != null) {
      map['completion_time'] = Variable<int>(completionTime);
    }
    if (!nullToAbsent || receiveWalletId != null) {
      map['receive_wallet_id'] = Variable<String>(receiveWalletId);
    }
    if (!nullToAbsent || sendWalletId != null) {
      map['send_wallet_id'] = Variable<String>(sendWalletId);
    }
    if (!nullToAbsent || invoice != null) {
      map['invoice'] = Variable<String>(invoice);
    }
    if (!nullToAbsent || paymentAddress != null) {
      map['payment_address'] = Variable<String>(paymentAddress);
    }
    if (!nullToAbsent || paymentAmount != null) {
      map['payment_amount'] = Variable<int>(paymentAmount);
    }
    if (!nullToAbsent || receiveAddress != null) {
      map['receive_address'] = Variable<String>(receiveAddress);
    }
    if (!nullToAbsent || receiveTxid != null) {
      map['receive_txid'] = Variable<String>(receiveTxid);
    }
    if (!nullToAbsent || sendTxid != null) {
      map['send_txid'] = Variable<String>(sendTxid);
    }
    if (!nullToAbsent || preimage != null) {
      map['preimage'] = Variable<String>(preimage);
    }
    if (!nullToAbsent || refundAddress != null) {
      map['refund_address'] = Variable<String>(refundAddress);
    }
    if (!nullToAbsent || refundTxid != null) {
      map['refund_txid'] = Variable<String>(refundTxid);
    }
    if (!nullToAbsent || boltzFees != null) {
      map['boltz_fees'] = Variable<int>(boltzFees);
    }
    if (!nullToAbsent || lockupFees != null) {
      map['lockup_fees'] = Variable<int>(lockupFees);
    }
    if (!nullToAbsent || claimFees != null) {
      map['claim_fees'] = Variable<int>(claimFees);
    }
    if (!nullToAbsent || serverNetworkFees != null) {
      map['server_network_fees'] = Variable<int>(serverNetworkFees);
    }
    return map;
  }

  SwapsCompanion toCompanion(bool nullToAbsent) {
    return SwapsCompanion(
      id: Value(id),
      type: Value(type),
      direction: Value(direction),
      status: Value(status),
      isTestnet: Value(isTestnet),
      keyIndex: Value(keyIndex),
      creationTime: Value(creationTime),
      completionTime: completionTime == null && nullToAbsent
          ? const Value.absent()
          : Value(completionTime),
      receiveWalletId: receiveWalletId == null && nullToAbsent
          ? const Value.absent()
          : Value(receiveWalletId),
      sendWalletId: sendWalletId == null && nullToAbsent
          ? const Value.absent()
          : Value(sendWalletId),
      invoice: invoice == null && nullToAbsent
          ? const Value.absent()
          : Value(invoice),
      paymentAddress: paymentAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(paymentAddress),
      paymentAmount: paymentAmount == null && nullToAbsent
          ? const Value.absent()
          : Value(paymentAmount),
      receiveAddress: receiveAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(receiveAddress),
      receiveTxid: receiveTxid == null && nullToAbsent
          ? const Value.absent()
          : Value(receiveTxid),
      sendTxid: sendTxid == null && nullToAbsent
          ? const Value.absent()
          : Value(sendTxid),
      preimage: preimage == null && nullToAbsent
          ? const Value.absent()
          : Value(preimage),
      refundAddress: refundAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(refundAddress),
      refundTxid: refundTxid == null && nullToAbsent
          ? const Value.absent()
          : Value(refundTxid),
      boltzFees: boltzFees == null && nullToAbsent
          ? const Value.absent()
          : Value(boltzFees),
      lockupFees: lockupFees == null && nullToAbsent
          ? const Value.absent()
          : Value(lockupFees),
      claimFees: claimFees == null && nullToAbsent
          ? const Value.absent()
          : Value(claimFees),
      serverNetworkFees: serverNetworkFees == null && nullToAbsent
          ? const Value.absent()
          : Value(serverNetworkFees),
    );
  }

  factory SwapsData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SwapsData(
      id: serializer.fromJson<String>(json['id']),
      type: serializer.fromJson<String>(json['type']),
      direction: serializer.fromJson<String>(json['direction']),
      status: serializer.fromJson<String>(json['status']),
      isTestnet: serializer.fromJson<int>(json['isTestnet']),
      keyIndex: serializer.fromJson<int>(json['keyIndex']),
      creationTime: serializer.fromJson<int>(json['creationTime']),
      completionTime: serializer.fromJson<int?>(json['completionTime']),
      receiveWalletId: serializer.fromJson<String?>(json['receiveWalletId']),
      sendWalletId: serializer.fromJson<String?>(json['sendWalletId']),
      invoice: serializer.fromJson<String?>(json['invoice']),
      paymentAddress: serializer.fromJson<String?>(json['paymentAddress']),
      paymentAmount: serializer.fromJson<int?>(json['paymentAmount']),
      receiveAddress: serializer.fromJson<String?>(json['receiveAddress']),
      receiveTxid: serializer.fromJson<String?>(json['receiveTxid']),
      sendTxid: serializer.fromJson<String?>(json['sendTxid']),
      preimage: serializer.fromJson<String?>(json['preimage']),
      refundAddress: serializer.fromJson<String?>(json['refundAddress']),
      refundTxid: serializer.fromJson<String?>(json['refundTxid']),
      boltzFees: serializer.fromJson<int?>(json['boltzFees']),
      lockupFees: serializer.fromJson<int?>(json['lockupFees']),
      claimFees: serializer.fromJson<int?>(json['claimFees']),
      serverNetworkFees: serializer.fromJson<int?>(json['serverNetworkFees']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'type': serializer.toJson<String>(type),
      'direction': serializer.toJson<String>(direction),
      'status': serializer.toJson<String>(status),
      'isTestnet': serializer.toJson<int>(isTestnet),
      'keyIndex': serializer.toJson<int>(keyIndex),
      'creationTime': serializer.toJson<int>(creationTime),
      'completionTime': serializer.toJson<int?>(completionTime),
      'receiveWalletId': serializer.toJson<String?>(receiveWalletId),
      'sendWalletId': serializer.toJson<String?>(sendWalletId),
      'invoice': serializer.toJson<String?>(invoice),
      'paymentAddress': serializer.toJson<String?>(paymentAddress),
      'paymentAmount': serializer.toJson<int?>(paymentAmount),
      'receiveAddress': serializer.toJson<String?>(receiveAddress),
      'receiveTxid': serializer.toJson<String?>(receiveTxid),
      'sendTxid': serializer.toJson<String?>(sendTxid),
      'preimage': serializer.toJson<String?>(preimage),
      'refundAddress': serializer.toJson<String?>(refundAddress),
      'refundTxid': serializer.toJson<String?>(refundTxid),
      'boltzFees': serializer.toJson<int?>(boltzFees),
      'lockupFees': serializer.toJson<int?>(lockupFees),
      'claimFees': serializer.toJson<int?>(claimFees),
      'serverNetworkFees': serializer.toJson<int?>(serverNetworkFees),
    };
  }

  SwapsData copyWith({
    String? id,
    String? type,
    String? direction,
    String? status,
    int? isTestnet,
    int? keyIndex,
    int? creationTime,
    Value<int?> completionTime = const Value.absent(),
    Value<String?> receiveWalletId = const Value.absent(),
    Value<String?> sendWalletId = const Value.absent(),
    Value<String?> invoice = const Value.absent(),
    Value<String?> paymentAddress = const Value.absent(),
    Value<int?> paymentAmount = const Value.absent(),
    Value<String?> receiveAddress = const Value.absent(),
    Value<String?> receiveTxid = const Value.absent(),
    Value<String?> sendTxid = const Value.absent(),
    Value<String?> preimage = const Value.absent(),
    Value<String?> refundAddress = const Value.absent(),
    Value<String?> refundTxid = const Value.absent(),
    Value<int?> boltzFees = const Value.absent(),
    Value<int?> lockupFees = const Value.absent(),
    Value<int?> claimFees = const Value.absent(),
    Value<int?> serverNetworkFees = const Value.absent(),
  }) => SwapsData(
    id: id ?? this.id,
    type: type ?? this.type,
    direction: direction ?? this.direction,
    status: status ?? this.status,
    isTestnet: isTestnet ?? this.isTestnet,
    keyIndex: keyIndex ?? this.keyIndex,
    creationTime: creationTime ?? this.creationTime,
    completionTime: completionTime.present
        ? completionTime.value
        : this.completionTime,
    receiveWalletId: receiveWalletId.present
        ? receiveWalletId.value
        : this.receiveWalletId,
    sendWalletId: sendWalletId.present ? sendWalletId.value : this.sendWalletId,
    invoice: invoice.present ? invoice.value : this.invoice,
    paymentAddress: paymentAddress.present
        ? paymentAddress.value
        : this.paymentAddress,
    paymentAmount: paymentAmount.present
        ? paymentAmount.value
        : this.paymentAmount,
    receiveAddress: receiveAddress.present
        ? receiveAddress.value
        : this.receiveAddress,
    receiveTxid: receiveTxid.present ? receiveTxid.value : this.receiveTxid,
    sendTxid: sendTxid.present ? sendTxid.value : this.sendTxid,
    preimage: preimage.present ? preimage.value : this.preimage,
    refundAddress: refundAddress.present
        ? refundAddress.value
        : this.refundAddress,
    refundTxid: refundTxid.present ? refundTxid.value : this.refundTxid,
    boltzFees: boltzFees.present ? boltzFees.value : this.boltzFees,
    lockupFees: lockupFees.present ? lockupFees.value : this.lockupFees,
    claimFees: claimFees.present ? claimFees.value : this.claimFees,
    serverNetworkFees: serverNetworkFees.present
        ? serverNetworkFees.value
        : this.serverNetworkFees,
  );
  SwapsData copyWithCompanion(SwapsCompanion data) {
    return SwapsData(
      id: data.id.present ? data.id.value : this.id,
      type: data.type.present ? data.type.value : this.type,
      direction: data.direction.present ? data.direction.value : this.direction,
      status: data.status.present ? data.status.value : this.status,
      isTestnet: data.isTestnet.present ? data.isTestnet.value : this.isTestnet,
      keyIndex: data.keyIndex.present ? data.keyIndex.value : this.keyIndex,
      creationTime: data.creationTime.present
          ? data.creationTime.value
          : this.creationTime,
      completionTime: data.completionTime.present
          ? data.completionTime.value
          : this.completionTime,
      receiveWalletId: data.receiveWalletId.present
          ? data.receiveWalletId.value
          : this.receiveWalletId,
      sendWalletId: data.sendWalletId.present
          ? data.sendWalletId.value
          : this.sendWalletId,
      invoice: data.invoice.present ? data.invoice.value : this.invoice,
      paymentAddress: data.paymentAddress.present
          ? data.paymentAddress.value
          : this.paymentAddress,
      paymentAmount: data.paymentAmount.present
          ? data.paymentAmount.value
          : this.paymentAmount,
      receiveAddress: data.receiveAddress.present
          ? data.receiveAddress.value
          : this.receiveAddress,
      receiveTxid: data.receiveTxid.present
          ? data.receiveTxid.value
          : this.receiveTxid,
      sendTxid: data.sendTxid.present ? data.sendTxid.value : this.sendTxid,
      preimage: data.preimage.present ? data.preimage.value : this.preimage,
      refundAddress: data.refundAddress.present
          ? data.refundAddress.value
          : this.refundAddress,
      refundTxid: data.refundTxid.present
          ? data.refundTxid.value
          : this.refundTxid,
      boltzFees: data.boltzFees.present ? data.boltzFees.value : this.boltzFees,
      lockupFees: data.lockupFees.present
          ? data.lockupFees.value
          : this.lockupFees,
      claimFees: data.claimFees.present ? data.claimFees.value : this.claimFees,
      serverNetworkFees: data.serverNetworkFees.present
          ? data.serverNetworkFees.value
          : this.serverNetworkFees,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SwapsData(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('direction: $direction, ')
          ..write('status: $status, ')
          ..write('isTestnet: $isTestnet, ')
          ..write('keyIndex: $keyIndex, ')
          ..write('creationTime: $creationTime, ')
          ..write('completionTime: $completionTime, ')
          ..write('receiveWalletId: $receiveWalletId, ')
          ..write('sendWalletId: $sendWalletId, ')
          ..write('invoice: $invoice, ')
          ..write('paymentAddress: $paymentAddress, ')
          ..write('paymentAmount: $paymentAmount, ')
          ..write('receiveAddress: $receiveAddress, ')
          ..write('receiveTxid: $receiveTxid, ')
          ..write('sendTxid: $sendTxid, ')
          ..write('preimage: $preimage, ')
          ..write('refundAddress: $refundAddress, ')
          ..write('refundTxid: $refundTxid, ')
          ..write('boltzFees: $boltzFees, ')
          ..write('lockupFees: $lockupFees, ')
          ..write('claimFees: $claimFees, ')
          ..write('serverNetworkFees: $serverNetworkFees')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    type,
    direction,
    status,
    isTestnet,
    keyIndex,
    creationTime,
    completionTime,
    receiveWalletId,
    sendWalletId,
    invoice,
    paymentAddress,
    paymentAmount,
    receiveAddress,
    receiveTxid,
    sendTxid,
    preimage,
    refundAddress,
    refundTxid,
    boltzFees,
    lockupFees,
    claimFees,
    serverNetworkFees,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SwapsData &&
          other.id == this.id &&
          other.type == this.type &&
          other.direction == this.direction &&
          other.status == this.status &&
          other.isTestnet == this.isTestnet &&
          other.keyIndex == this.keyIndex &&
          other.creationTime == this.creationTime &&
          other.completionTime == this.completionTime &&
          other.receiveWalletId == this.receiveWalletId &&
          other.sendWalletId == this.sendWalletId &&
          other.invoice == this.invoice &&
          other.paymentAddress == this.paymentAddress &&
          other.paymentAmount == this.paymentAmount &&
          other.receiveAddress == this.receiveAddress &&
          other.receiveTxid == this.receiveTxid &&
          other.sendTxid == this.sendTxid &&
          other.preimage == this.preimage &&
          other.refundAddress == this.refundAddress &&
          other.refundTxid == this.refundTxid &&
          other.boltzFees == this.boltzFees &&
          other.lockupFees == this.lockupFees &&
          other.claimFees == this.claimFees &&
          other.serverNetworkFees == this.serverNetworkFees);
}

class SwapsCompanion extends UpdateCompanion<SwapsData> {
  final Value<String> id;
  final Value<String> type;
  final Value<String> direction;
  final Value<String> status;
  final Value<int> isTestnet;
  final Value<int> keyIndex;
  final Value<int> creationTime;
  final Value<int?> completionTime;
  final Value<String?> receiveWalletId;
  final Value<String?> sendWalletId;
  final Value<String?> invoice;
  final Value<String?> paymentAddress;
  final Value<int?> paymentAmount;
  final Value<String?> receiveAddress;
  final Value<String?> receiveTxid;
  final Value<String?> sendTxid;
  final Value<String?> preimage;
  final Value<String?> refundAddress;
  final Value<String?> refundTxid;
  final Value<int?> boltzFees;
  final Value<int?> lockupFees;
  final Value<int?> claimFees;
  final Value<int?> serverNetworkFees;
  final Value<int> rowid;
  const SwapsCompanion({
    this.id = const Value.absent(),
    this.type = const Value.absent(),
    this.direction = const Value.absent(),
    this.status = const Value.absent(),
    this.isTestnet = const Value.absent(),
    this.keyIndex = const Value.absent(),
    this.creationTime = const Value.absent(),
    this.completionTime = const Value.absent(),
    this.receiveWalletId = const Value.absent(),
    this.sendWalletId = const Value.absent(),
    this.invoice = const Value.absent(),
    this.paymentAddress = const Value.absent(),
    this.paymentAmount = const Value.absent(),
    this.receiveAddress = const Value.absent(),
    this.receiveTxid = const Value.absent(),
    this.sendTxid = const Value.absent(),
    this.preimage = const Value.absent(),
    this.refundAddress = const Value.absent(),
    this.refundTxid = const Value.absent(),
    this.boltzFees = const Value.absent(),
    this.lockupFees = const Value.absent(),
    this.claimFees = const Value.absent(),
    this.serverNetworkFees = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SwapsCompanion.insert({
    required String id,
    required String type,
    required String direction,
    required String status,
    required int isTestnet,
    required int keyIndex,
    required int creationTime,
    this.completionTime = const Value.absent(),
    this.receiveWalletId = const Value.absent(),
    this.sendWalletId = const Value.absent(),
    this.invoice = const Value.absent(),
    this.paymentAddress = const Value.absent(),
    this.paymentAmount = const Value.absent(),
    this.receiveAddress = const Value.absent(),
    this.receiveTxid = const Value.absent(),
    this.sendTxid = const Value.absent(),
    this.preimage = const Value.absent(),
    this.refundAddress = const Value.absent(),
    this.refundTxid = const Value.absent(),
    this.boltzFees = const Value.absent(),
    this.lockupFees = const Value.absent(),
    this.claimFees = const Value.absent(),
    this.serverNetworkFees = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       type = Value(type),
       direction = Value(direction),
       status = Value(status),
       isTestnet = Value(isTestnet),
       keyIndex = Value(keyIndex),
       creationTime = Value(creationTime);
  static Insertable<SwapsData> custom({
    Expression<String>? id,
    Expression<String>? type,
    Expression<String>? direction,
    Expression<String>? status,
    Expression<int>? isTestnet,
    Expression<int>? keyIndex,
    Expression<int>? creationTime,
    Expression<int>? completionTime,
    Expression<String>? receiveWalletId,
    Expression<String>? sendWalletId,
    Expression<String>? invoice,
    Expression<String>? paymentAddress,
    Expression<int>? paymentAmount,
    Expression<String>? receiveAddress,
    Expression<String>? receiveTxid,
    Expression<String>? sendTxid,
    Expression<String>? preimage,
    Expression<String>? refundAddress,
    Expression<String>? refundTxid,
    Expression<int>? boltzFees,
    Expression<int>? lockupFees,
    Expression<int>? claimFees,
    Expression<int>? serverNetworkFees,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (type != null) 'type': type,
      if (direction != null) 'direction': direction,
      if (status != null) 'status': status,
      if (isTestnet != null) 'is_testnet': isTestnet,
      if (keyIndex != null) 'key_index': keyIndex,
      if (creationTime != null) 'creation_time': creationTime,
      if (completionTime != null) 'completion_time': completionTime,
      if (receiveWalletId != null) 'receive_wallet_id': receiveWalletId,
      if (sendWalletId != null) 'send_wallet_id': sendWalletId,
      if (invoice != null) 'invoice': invoice,
      if (paymentAddress != null) 'payment_address': paymentAddress,
      if (paymentAmount != null) 'payment_amount': paymentAmount,
      if (receiveAddress != null) 'receive_address': receiveAddress,
      if (receiveTxid != null) 'receive_txid': receiveTxid,
      if (sendTxid != null) 'send_txid': sendTxid,
      if (preimage != null) 'preimage': preimage,
      if (refundAddress != null) 'refund_address': refundAddress,
      if (refundTxid != null) 'refund_txid': refundTxid,
      if (boltzFees != null) 'boltz_fees': boltzFees,
      if (lockupFees != null) 'lockup_fees': lockupFees,
      if (claimFees != null) 'claim_fees': claimFees,
      if (serverNetworkFees != null) 'server_network_fees': serverNetworkFees,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SwapsCompanion copyWith({
    Value<String>? id,
    Value<String>? type,
    Value<String>? direction,
    Value<String>? status,
    Value<int>? isTestnet,
    Value<int>? keyIndex,
    Value<int>? creationTime,
    Value<int?>? completionTime,
    Value<String?>? receiveWalletId,
    Value<String?>? sendWalletId,
    Value<String?>? invoice,
    Value<String?>? paymentAddress,
    Value<int?>? paymentAmount,
    Value<String?>? receiveAddress,
    Value<String?>? receiveTxid,
    Value<String?>? sendTxid,
    Value<String?>? preimage,
    Value<String?>? refundAddress,
    Value<String?>? refundTxid,
    Value<int?>? boltzFees,
    Value<int?>? lockupFees,
    Value<int?>? claimFees,
    Value<int?>? serverNetworkFees,
    Value<int>? rowid,
  }) {
    return SwapsCompanion(
      id: id ?? this.id,
      type: type ?? this.type,
      direction: direction ?? this.direction,
      status: status ?? this.status,
      isTestnet: isTestnet ?? this.isTestnet,
      keyIndex: keyIndex ?? this.keyIndex,
      creationTime: creationTime ?? this.creationTime,
      completionTime: completionTime ?? this.completionTime,
      receiveWalletId: receiveWalletId ?? this.receiveWalletId,
      sendWalletId: sendWalletId ?? this.sendWalletId,
      invoice: invoice ?? this.invoice,
      paymentAddress: paymentAddress ?? this.paymentAddress,
      paymentAmount: paymentAmount ?? this.paymentAmount,
      receiveAddress: receiveAddress ?? this.receiveAddress,
      receiveTxid: receiveTxid ?? this.receiveTxid,
      sendTxid: sendTxid ?? this.sendTxid,
      preimage: preimage ?? this.preimage,
      refundAddress: refundAddress ?? this.refundAddress,
      refundTxid: refundTxid ?? this.refundTxid,
      boltzFees: boltzFees ?? this.boltzFees,
      lockupFees: lockupFees ?? this.lockupFees,
      claimFees: claimFees ?? this.claimFees,
      serverNetworkFees: serverNetworkFees ?? this.serverNetworkFees,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (direction.present) {
      map['direction'] = Variable<String>(direction.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (isTestnet.present) {
      map['is_testnet'] = Variable<int>(isTestnet.value);
    }
    if (keyIndex.present) {
      map['key_index'] = Variable<int>(keyIndex.value);
    }
    if (creationTime.present) {
      map['creation_time'] = Variable<int>(creationTime.value);
    }
    if (completionTime.present) {
      map['completion_time'] = Variable<int>(completionTime.value);
    }
    if (receiveWalletId.present) {
      map['receive_wallet_id'] = Variable<String>(receiveWalletId.value);
    }
    if (sendWalletId.present) {
      map['send_wallet_id'] = Variable<String>(sendWalletId.value);
    }
    if (invoice.present) {
      map['invoice'] = Variable<String>(invoice.value);
    }
    if (paymentAddress.present) {
      map['payment_address'] = Variable<String>(paymentAddress.value);
    }
    if (paymentAmount.present) {
      map['payment_amount'] = Variable<int>(paymentAmount.value);
    }
    if (receiveAddress.present) {
      map['receive_address'] = Variable<String>(receiveAddress.value);
    }
    if (receiveTxid.present) {
      map['receive_txid'] = Variable<String>(receiveTxid.value);
    }
    if (sendTxid.present) {
      map['send_txid'] = Variable<String>(sendTxid.value);
    }
    if (preimage.present) {
      map['preimage'] = Variable<String>(preimage.value);
    }
    if (refundAddress.present) {
      map['refund_address'] = Variable<String>(refundAddress.value);
    }
    if (refundTxid.present) {
      map['refund_txid'] = Variable<String>(refundTxid.value);
    }
    if (boltzFees.present) {
      map['boltz_fees'] = Variable<int>(boltzFees.value);
    }
    if (lockupFees.present) {
      map['lockup_fees'] = Variable<int>(lockupFees.value);
    }
    if (claimFees.present) {
      map['claim_fees'] = Variable<int>(claimFees.value);
    }
    if (serverNetworkFees.present) {
      map['server_network_fees'] = Variable<int>(serverNetworkFees.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SwapsCompanion(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('direction: $direction, ')
          ..write('status: $status, ')
          ..write('isTestnet: $isTestnet, ')
          ..write('keyIndex: $keyIndex, ')
          ..write('creationTime: $creationTime, ')
          ..write('completionTime: $completionTime, ')
          ..write('receiveWalletId: $receiveWalletId, ')
          ..write('sendWalletId: $sendWalletId, ')
          ..write('invoice: $invoice, ')
          ..write('paymentAddress: $paymentAddress, ')
          ..write('paymentAmount: $paymentAmount, ')
          ..write('receiveAddress: $receiveAddress, ')
          ..write('receiveTxid: $receiveTxid, ')
          ..write('sendTxid: $sendTxid, ')
          ..write('preimage: $preimage, ')
          ..write('refundAddress: $refundAddress, ')
          ..write('refundTxid: $refundTxid, ')
          ..write('boltzFees: $boltzFees, ')
          ..write('lockupFees: $lockupFees, ')
          ..write('claimFees: $claimFees, ')
          ..write('serverNetworkFees: $serverNetworkFees, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class AutoSwap extends Table with TableInfo<AutoSwap, AutoSwapData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  AutoSwap(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT',
  );
  late final GeneratedColumn<int> enabled = GeneratedColumn<int>(
    'enabled',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL DEFAULT 1 CHECK (enabled IN (0, 1))',
    defaultValue: const CustomExpression('1'),
  );
  late final GeneratedColumn<int> balanceThresholdSats = GeneratedColumn<int>(
    'balance_threshold_sats',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> triggerBalanceSats = GeneratedColumn<int>(
    'trigger_balance_sats',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<double> feeThresholdPercent =
      GeneratedColumn<double>(
        'fee_threshold_percent',
        aliasedName,
        false,
        type: DriftSqlType.double,
        requiredDuringInsert: true,
        $customConstraints: 'NOT NULL',
      );
  late final GeneratedColumn<int> blockTillNextExecution = GeneratedColumn<int>(
    'block_till_next_execution',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints:
        'NOT NULL DEFAULT 0 CHECK (block_till_next_execution IN (0, 1))',
    defaultValue: const CustomExpression('0'),
  );
  late final GeneratedColumn<int> alwaysBlock = GeneratedColumn<int>(
    'always_block',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL DEFAULT 0 CHECK (always_block IN (0, 1))',
    defaultValue: const CustomExpression('0'),
  );
  late final GeneratedColumn<String> recipientWalletId =
      GeneratedColumn<String>(
        'recipient_wallet_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
        $customConstraints: 'NULL',
      );
  late final GeneratedColumn<int> showWarning = GeneratedColumn<int>(
    'show_warning',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL DEFAULT 1 CHECK (show_warning IN (0, 1))',
    defaultValue: const CustomExpression('1'),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    enabled,
    balanceThresholdSats,
    triggerBalanceSats,
    feeThresholdPercent,
    blockTillNextExecution,
    alwaysBlock,
    recipientWalletId,
    showWarning,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'auto_swap';
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AutoSwapData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AutoSwapData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      enabled: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}enabled'],
      )!,
      balanceThresholdSats: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}balance_threshold_sats'],
      )!,
      triggerBalanceSats: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}trigger_balance_sats'],
      )!,
      feeThresholdPercent: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}fee_threshold_percent'],
      )!,
      blockTillNextExecution: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}block_till_next_execution'],
      )!,
      alwaysBlock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}always_block'],
      )!,
      recipientWalletId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}recipient_wallet_id'],
      ),
      showWarning: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}show_warning'],
      )!,
    );
  }

  @override
  AutoSwap createAlias(String alias) {
    return AutoSwap(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class AutoSwapData extends DataClass implements Insertable<AutoSwapData> {
  final int id;
  final int enabled;
  final int balanceThresholdSats;
  final int triggerBalanceSats;
  final double feeThresholdPercent;
  final int blockTillNextExecution;
  final int alwaysBlock;
  final String? recipientWalletId;
  final int showWarning;
  const AutoSwapData({
    required this.id,
    required this.enabled,
    required this.balanceThresholdSats,
    required this.triggerBalanceSats,
    required this.feeThresholdPercent,
    required this.blockTillNextExecution,
    required this.alwaysBlock,
    this.recipientWalletId,
    required this.showWarning,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['enabled'] = Variable<int>(enabled);
    map['balance_threshold_sats'] = Variable<int>(balanceThresholdSats);
    map['trigger_balance_sats'] = Variable<int>(triggerBalanceSats);
    map['fee_threshold_percent'] = Variable<double>(feeThresholdPercent);
    map['block_till_next_execution'] = Variable<int>(blockTillNextExecution);
    map['always_block'] = Variable<int>(alwaysBlock);
    if (!nullToAbsent || recipientWalletId != null) {
      map['recipient_wallet_id'] = Variable<String>(recipientWalletId);
    }
    map['show_warning'] = Variable<int>(showWarning);
    return map;
  }

  AutoSwapCompanion toCompanion(bool nullToAbsent) {
    return AutoSwapCompanion(
      id: Value(id),
      enabled: Value(enabled),
      balanceThresholdSats: Value(balanceThresholdSats),
      triggerBalanceSats: Value(triggerBalanceSats),
      feeThresholdPercent: Value(feeThresholdPercent),
      blockTillNextExecution: Value(blockTillNextExecution),
      alwaysBlock: Value(alwaysBlock),
      recipientWalletId: recipientWalletId == null && nullToAbsent
          ? const Value.absent()
          : Value(recipientWalletId),
      showWarning: Value(showWarning),
    );
  }

  factory AutoSwapData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AutoSwapData(
      id: serializer.fromJson<int>(json['id']),
      enabled: serializer.fromJson<int>(json['enabled']),
      balanceThresholdSats: serializer.fromJson<int>(
        json['balanceThresholdSats'],
      ),
      triggerBalanceSats: serializer.fromJson<int>(json['triggerBalanceSats']),
      feeThresholdPercent: serializer.fromJson<double>(
        json['feeThresholdPercent'],
      ),
      blockTillNextExecution: serializer.fromJson<int>(
        json['blockTillNextExecution'],
      ),
      alwaysBlock: serializer.fromJson<int>(json['alwaysBlock']),
      recipientWalletId: serializer.fromJson<String?>(
        json['recipientWalletId'],
      ),
      showWarning: serializer.fromJson<int>(json['showWarning']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'enabled': serializer.toJson<int>(enabled),
      'balanceThresholdSats': serializer.toJson<int>(balanceThresholdSats),
      'triggerBalanceSats': serializer.toJson<int>(triggerBalanceSats),
      'feeThresholdPercent': serializer.toJson<double>(feeThresholdPercent),
      'blockTillNextExecution': serializer.toJson<int>(blockTillNextExecution),
      'alwaysBlock': serializer.toJson<int>(alwaysBlock),
      'recipientWalletId': serializer.toJson<String?>(recipientWalletId),
      'showWarning': serializer.toJson<int>(showWarning),
    };
  }

  AutoSwapData copyWith({
    int? id,
    int? enabled,
    int? balanceThresholdSats,
    int? triggerBalanceSats,
    double? feeThresholdPercent,
    int? blockTillNextExecution,
    int? alwaysBlock,
    Value<String?> recipientWalletId = const Value.absent(),
    int? showWarning,
  }) => AutoSwapData(
    id: id ?? this.id,
    enabled: enabled ?? this.enabled,
    balanceThresholdSats: balanceThresholdSats ?? this.balanceThresholdSats,
    triggerBalanceSats: triggerBalanceSats ?? this.triggerBalanceSats,
    feeThresholdPercent: feeThresholdPercent ?? this.feeThresholdPercent,
    blockTillNextExecution:
        blockTillNextExecution ?? this.blockTillNextExecution,
    alwaysBlock: alwaysBlock ?? this.alwaysBlock,
    recipientWalletId: recipientWalletId.present
        ? recipientWalletId.value
        : this.recipientWalletId,
    showWarning: showWarning ?? this.showWarning,
  );
  AutoSwapData copyWithCompanion(AutoSwapCompanion data) {
    return AutoSwapData(
      id: data.id.present ? data.id.value : this.id,
      enabled: data.enabled.present ? data.enabled.value : this.enabled,
      balanceThresholdSats: data.balanceThresholdSats.present
          ? data.balanceThresholdSats.value
          : this.balanceThresholdSats,
      triggerBalanceSats: data.triggerBalanceSats.present
          ? data.triggerBalanceSats.value
          : this.triggerBalanceSats,
      feeThresholdPercent: data.feeThresholdPercent.present
          ? data.feeThresholdPercent.value
          : this.feeThresholdPercent,
      blockTillNextExecution: data.blockTillNextExecution.present
          ? data.blockTillNextExecution.value
          : this.blockTillNextExecution,
      alwaysBlock: data.alwaysBlock.present
          ? data.alwaysBlock.value
          : this.alwaysBlock,
      recipientWalletId: data.recipientWalletId.present
          ? data.recipientWalletId.value
          : this.recipientWalletId,
      showWarning: data.showWarning.present
          ? data.showWarning.value
          : this.showWarning,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AutoSwapData(')
          ..write('id: $id, ')
          ..write('enabled: $enabled, ')
          ..write('balanceThresholdSats: $balanceThresholdSats, ')
          ..write('triggerBalanceSats: $triggerBalanceSats, ')
          ..write('feeThresholdPercent: $feeThresholdPercent, ')
          ..write('blockTillNextExecution: $blockTillNextExecution, ')
          ..write('alwaysBlock: $alwaysBlock, ')
          ..write('recipientWalletId: $recipientWalletId, ')
          ..write('showWarning: $showWarning')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    enabled,
    balanceThresholdSats,
    triggerBalanceSats,
    feeThresholdPercent,
    blockTillNextExecution,
    alwaysBlock,
    recipientWalletId,
    showWarning,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AutoSwapData &&
          other.id == this.id &&
          other.enabled == this.enabled &&
          other.balanceThresholdSats == this.balanceThresholdSats &&
          other.triggerBalanceSats == this.triggerBalanceSats &&
          other.feeThresholdPercent == this.feeThresholdPercent &&
          other.blockTillNextExecution == this.blockTillNextExecution &&
          other.alwaysBlock == this.alwaysBlock &&
          other.recipientWalletId == this.recipientWalletId &&
          other.showWarning == this.showWarning);
}

class AutoSwapCompanion extends UpdateCompanion<AutoSwapData> {
  final Value<int> id;
  final Value<int> enabled;
  final Value<int> balanceThresholdSats;
  final Value<int> triggerBalanceSats;
  final Value<double> feeThresholdPercent;
  final Value<int> blockTillNextExecution;
  final Value<int> alwaysBlock;
  final Value<String?> recipientWalletId;
  final Value<int> showWarning;
  const AutoSwapCompanion({
    this.id = const Value.absent(),
    this.enabled = const Value.absent(),
    this.balanceThresholdSats = const Value.absent(),
    this.triggerBalanceSats = const Value.absent(),
    this.feeThresholdPercent = const Value.absent(),
    this.blockTillNextExecution = const Value.absent(),
    this.alwaysBlock = const Value.absent(),
    this.recipientWalletId = const Value.absent(),
    this.showWarning = const Value.absent(),
  });
  AutoSwapCompanion.insert({
    this.id = const Value.absent(),
    this.enabled = const Value.absent(),
    required int balanceThresholdSats,
    required int triggerBalanceSats,
    required double feeThresholdPercent,
    this.blockTillNextExecution = const Value.absent(),
    this.alwaysBlock = const Value.absent(),
    this.recipientWalletId = const Value.absent(),
    this.showWarning = const Value.absent(),
  }) : balanceThresholdSats = Value(balanceThresholdSats),
       triggerBalanceSats = Value(triggerBalanceSats),
       feeThresholdPercent = Value(feeThresholdPercent);
  static Insertable<AutoSwapData> custom({
    Expression<int>? id,
    Expression<int>? enabled,
    Expression<int>? balanceThresholdSats,
    Expression<int>? triggerBalanceSats,
    Expression<double>? feeThresholdPercent,
    Expression<int>? blockTillNextExecution,
    Expression<int>? alwaysBlock,
    Expression<String>? recipientWalletId,
    Expression<int>? showWarning,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (enabled != null) 'enabled': enabled,
      if (balanceThresholdSats != null)
        'balance_threshold_sats': balanceThresholdSats,
      if (triggerBalanceSats != null)
        'trigger_balance_sats': triggerBalanceSats,
      if (feeThresholdPercent != null)
        'fee_threshold_percent': feeThresholdPercent,
      if (blockTillNextExecution != null)
        'block_till_next_execution': blockTillNextExecution,
      if (alwaysBlock != null) 'always_block': alwaysBlock,
      if (recipientWalletId != null) 'recipient_wallet_id': recipientWalletId,
      if (showWarning != null) 'show_warning': showWarning,
    });
  }

  AutoSwapCompanion copyWith({
    Value<int>? id,
    Value<int>? enabled,
    Value<int>? balanceThresholdSats,
    Value<int>? triggerBalanceSats,
    Value<double>? feeThresholdPercent,
    Value<int>? blockTillNextExecution,
    Value<int>? alwaysBlock,
    Value<String?>? recipientWalletId,
    Value<int>? showWarning,
  }) {
    return AutoSwapCompanion(
      id: id ?? this.id,
      enabled: enabled ?? this.enabled,
      balanceThresholdSats: balanceThresholdSats ?? this.balanceThresholdSats,
      triggerBalanceSats: triggerBalanceSats ?? this.triggerBalanceSats,
      feeThresholdPercent: feeThresholdPercent ?? this.feeThresholdPercent,
      blockTillNextExecution:
          blockTillNextExecution ?? this.blockTillNextExecution,
      alwaysBlock: alwaysBlock ?? this.alwaysBlock,
      recipientWalletId: recipientWalletId ?? this.recipientWalletId,
      showWarning: showWarning ?? this.showWarning,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (enabled.present) {
      map['enabled'] = Variable<int>(enabled.value);
    }
    if (balanceThresholdSats.present) {
      map['balance_threshold_sats'] = Variable<int>(balanceThresholdSats.value);
    }
    if (triggerBalanceSats.present) {
      map['trigger_balance_sats'] = Variable<int>(triggerBalanceSats.value);
    }
    if (feeThresholdPercent.present) {
      map['fee_threshold_percent'] = Variable<double>(
        feeThresholdPercent.value,
      );
    }
    if (blockTillNextExecution.present) {
      map['block_till_next_execution'] = Variable<int>(
        blockTillNextExecution.value,
      );
    }
    if (alwaysBlock.present) {
      map['always_block'] = Variable<int>(alwaysBlock.value);
    }
    if (recipientWalletId.present) {
      map['recipient_wallet_id'] = Variable<String>(recipientWalletId.value);
    }
    if (showWarning.present) {
      map['show_warning'] = Variable<int>(showWarning.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AutoSwapCompanion(')
          ..write('id: $id, ')
          ..write('enabled: $enabled, ')
          ..write('balanceThresholdSats: $balanceThresholdSats, ')
          ..write('triggerBalanceSats: $triggerBalanceSats, ')
          ..write('feeThresholdPercent: $feeThresholdPercent, ')
          ..write('blockTillNextExecution: $blockTillNextExecution, ')
          ..write('alwaysBlock: $alwaysBlock, ')
          ..write('recipientWalletId: $recipientWalletId, ')
          ..write('showWarning: $showWarning')
          ..write(')'))
        .toString();
  }
}

class Bip85Derivations extends Table
    with TableInfo<Bip85Derivations, Bip85DerivationsData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Bip85Derivations(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<String> path = GeneratedColumn<String>(
    'path',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> xprvFingerprint = GeneratedColumn<String>(
    'xprv_fingerprint',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> application = GeneratedColumn<String>(
    'application',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> alias = GeneratedColumn<String>(
    'alias',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  @override
  List<GeneratedColumn> get $columns => [
    path,
    xprvFingerprint,
    application,
    status,
    alias,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'bip85_derivations';
  @override
  Set<GeneratedColumn> get $primaryKey => {path};
  @override
  Bip85DerivationsData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Bip85DerivationsData(
      path: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}path'],
      )!,
      xprvFingerprint: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}xprv_fingerprint'],
      )!,
      application: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}application'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      alias: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}alias'],
      ),
    );
  }

  @override
  Bip85Derivations createAlias(String alias) {
    return Bip85Derivations(attachedDatabase, alias);
  }

  @override
  List<String> get customConstraints => const ['PRIMARY KEY(path)'];
  @override
  bool get dontWriteConstraints => true;
}

class Bip85DerivationsData extends DataClass
    implements Insertable<Bip85DerivationsData> {
  final String path;
  final String xprvFingerprint;
  final String application;
  final String status;
  final String? alias;
  const Bip85DerivationsData({
    required this.path,
    required this.xprvFingerprint,
    required this.application,
    required this.status,
    this.alias,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['path'] = Variable<String>(path);
    map['xprv_fingerprint'] = Variable<String>(xprvFingerprint);
    map['application'] = Variable<String>(application);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || alias != null) {
      map['alias'] = Variable<String>(alias);
    }
    return map;
  }

  Bip85DerivationsCompanion toCompanion(bool nullToAbsent) {
    return Bip85DerivationsCompanion(
      path: Value(path),
      xprvFingerprint: Value(xprvFingerprint),
      application: Value(application),
      status: Value(status),
      alias: alias == null && nullToAbsent
          ? const Value.absent()
          : Value(alias),
    );
  }

  factory Bip85DerivationsData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Bip85DerivationsData(
      path: serializer.fromJson<String>(json['path']),
      xprvFingerprint: serializer.fromJson<String>(json['xprvFingerprint']),
      application: serializer.fromJson<String>(json['application']),
      status: serializer.fromJson<String>(json['status']),
      alias: serializer.fromJson<String?>(json['alias']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'path': serializer.toJson<String>(path),
      'xprvFingerprint': serializer.toJson<String>(xprvFingerprint),
      'application': serializer.toJson<String>(application),
      'status': serializer.toJson<String>(status),
      'alias': serializer.toJson<String?>(alias),
    };
  }

  Bip85DerivationsData copyWith({
    String? path,
    String? xprvFingerprint,
    String? application,
    String? status,
    Value<String?> alias = const Value.absent(),
  }) => Bip85DerivationsData(
    path: path ?? this.path,
    xprvFingerprint: xprvFingerprint ?? this.xprvFingerprint,
    application: application ?? this.application,
    status: status ?? this.status,
    alias: alias.present ? alias.value : this.alias,
  );
  Bip85DerivationsData copyWithCompanion(Bip85DerivationsCompanion data) {
    return Bip85DerivationsData(
      path: data.path.present ? data.path.value : this.path,
      xprvFingerprint: data.xprvFingerprint.present
          ? data.xprvFingerprint.value
          : this.xprvFingerprint,
      application: data.application.present
          ? data.application.value
          : this.application,
      status: data.status.present ? data.status.value : this.status,
      alias: data.alias.present ? data.alias.value : this.alias,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Bip85DerivationsData(')
          ..write('path: $path, ')
          ..write('xprvFingerprint: $xprvFingerprint, ')
          ..write('application: $application, ')
          ..write('status: $status, ')
          ..write('alias: $alias')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(path, xprvFingerprint, application, status, alias);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Bip85DerivationsData &&
          other.path == this.path &&
          other.xprvFingerprint == this.xprvFingerprint &&
          other.application == this.application &&
          other.status == this.status &&
          other.alias == this.alias);
}

class Bip85DerivationsCompanion extends UpdateCompanion<Bip85DerivationsData> {
  final Value<String> path;
  final Value<String> xprvFingerprint;
  final Value<String> application;
  final Value<String> status;
  final Value<String?> alias;
  final Value<int> rowid;
  const Bip85DerivationsCompanion({
    this.path = const Value.absent(),
    this.xprvFingerprint = const Value.absent(),
    this.application = const Value.absent(),
    this.status = const Value.absent(),
    this.alias = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  Bip85DerivationsCompanion.insert({
    required String path,
    required String xprvFingerprint,
    required String application,
    required String status,
    this.alias = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : path = Value(path),
       xprvFingerprint = Value(xprvFingerprint),
       application = Value(application),
       status = Value(status);
  static Insertable<Bip85DerivationsData> custom({
    Expression<String>? path,
    Expression<String>? xprvFingerprint,
    Expression<String>? application,
    Expression<String>? status,
    Expression<String>? alias,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (path != null) 'path': path,
      if (xprvFingerprint != null) 'xprv_fingerprint': xprvFingerprint,
      if (application != null) 'application': application,
      if (status != null) 'status': status,
      if (alias != null) 'alias': alias,
      if (rowid != null) 'rowid': rowid,
    });
  }

  Bip85DerivationsCompanion copyWith({
    Value<String>? path,
    Value<String>? xprvFingerprint,
    Value<String>? application,
    Value<String>? status,
    Value<String?>? alias,
    Value<int>? rowid,
  }) {
    return Bip85DerivationsCompanion(
      path: path ?? this.path,
      xprvFingerprint: xprvFingerprint ?? this.xprvFingerprint,
      application: application ?? this.application,
      status: status ?? this.status,
      alias: alias ?? this.alias,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (path.present) {
      map['path'] = Variable<String>(path.value);
    }
    if (xprvFingerprint.present) {
      map['xprv_fingerprint'] = Variable<String>(xprvFingerprint.value);
    }
    if (application.present) {
      map['application'] = Variable<String>(application.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (alias.present) {
      map['alias'] = Variable<String>(alias.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('Bip85DerivationsCompanion(')
          ..write('path: $path, ')
          ..write('xprvFingerprint: $xprvFingerprint, ')
          ..write('application: $application, ')
          ..write('status: $status, ')
          ..write('alias: $alias, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class Recoverbull extends Table with TableInfo<Recoverbull, RecoverbullData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Recoverbull(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT',
  );
  late final GeneratedColumn<String> url = GeneratedColumn<String>(
    'url',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<int> isPermissionGranted = GeneratedColumn<int>(
    'is_permission_granted',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL CHECK (is_permission_granted IN (0, 1))',
  );
  @override
  List<GeneratedColumn> get $columns => [id, url, isPermissionGranted];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'recoverbull';
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RecoverbullData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RecoverbullData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      url: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}url'],
      )!,
      isPermissionGranted: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}is_permission_granted'],
      )!,
    );
  }

  @override
  Recoverbull createAlias(String alias) {
    return Recoverbull(attachedDatabase, alias);
  }

  @override
  bool get dontWriteConstraints => true;
}

class RecoverbullData extends DataClass implements Insertable<RecoverbullData> {
  final int id;
  final String url;
  final int isPermissionGranted;
  const RecoverbullData({
    required this.id,
    required this.url,
    required this.isPermissionGranted,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['url'] = Variable<String>(url);
    map['is_permission_granted'] = Variable<int>(isPermissionGranted);
    return map;
  }

  RecoverbullCompanion toCompanion(bool nullToAbsent) {
    return RecoverbullCompanion(
      id: Value(id),
      url: Value(url),
      isPermissionGranted: Value(isPermissionGranted),
    );
  }

  factory RecoverbullData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RecoverbullData(
      id: serializer.fromJson<int>(json['id']),
      url: serializer.fromJson<String>(json['url']),
      isPermissionGranted: serializer.fromJson<int>(
        json['isPermissionGranted'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'url': serializer.toJson<String>(url),
      'isPermissionGranted': serializer.toJson<int>(isPermissionGranted),
    };
  }

  RecoverbullData copyWith({int? id, String? url, int? isPermissionGranted}) =>
      RecoverbullData(
        id: id ?? this.id,
        url: url ?? this.url,
        isPermissionGranted: isPermissionGranted ?? this.isPermissionGranted,
      );
  RecoverbullData copyWithCompanion(RecoverbullCompanion data) {
    return RecoverbullData(
      id: data.id.present ? data.id.value : this.id,
      url: data.url.present ? data.url.value : this.url,
      isPermissionGranted: data.isPermissionGranted.present
          ? data.isPermissionGranted.value
          : this.isPermissionGranted,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RecoverbullData(')
          ..write('id: $id, ')
          ..write('url: $url, ')
          ..write('isPermissionGranted: $isPermissionGranted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, url, isPermissionGranted);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RecoverbullData &&
          other.id == this.id &&
          other.url == this.url &&
          other.isPermissionGranted == this.isPermissionGranted);
}

class RecoverbullCompanion extends UpdateCompanion<RecoverbullData> {
  final Value<int> id;
  final Value<String> url;
  final Value<int> isPermissionGranted;
  const RecoverbullCompanion({
    this.id = const Value.absent(),
    this.url = const Value.absent(),
    this.isPermissionGranted = const Value.absent(),
  });
  RecoverbullCompanion.insert({
    this.id = const Value.absent(),
    required String url,
    required int isPermissionGranted,
  }) : url = Value(url),
       isPermissionGranted = Value(isPermissionGranted);
  static Insertable<RecoverbullData> custom({
    Expression<int>? id,
    Expression<String>? url,
    Expression<int>? isPermissionGranted,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (url != null) 'url': url,
      if (isPermissionGranted != null)
        'is_permission_granted': isPermissionGranted,
    });
  }

  RecoverbullCompanion copyWith({
    Value<int>? id,
    Value<String>? url,
    Value<int>? isPermissionGranted,
  }) {
    return RecoverbullCompanion(
      id: id ?? this.id,
      url: url ?? this.url,
      isPermissionGranted: isPermissionGranted ?? this.isPermissionGranted,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (url.present) {
      map['url'] = Variable<String>(url.value);
    }
    if (isPermissionGranted.present) {
      map['is_permission_granted'] = Variable<int>(isPermissionGranted.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RecoverbullCompanion(')
          ..write('id: $id, ')
          ..write('url: $url, ')
          ..write('isPermissionGranted: $isPermissionGranted')
          ..write(')'))
        .toString();
  }
}

class Prices extends Table with TableInfo<Prices, PricesData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  Prices(this.attachedDatabase, [this._alias]);
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NOT NULL PRIMARY KEY AUTOINCREMENT',
  );
  late final GeneratedColumn<String> fromCurrency = GeneratedColumn<String>(
    'from_currency',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> toCurrency = GeneratedColumn<String>(
    'to_currency',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<String> interval = GeneratedColumn<String>(
    'interval',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  late final GeneratedColumn<double> marketPrice = GeneratedColumn<double>(
    'market_price',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
    'price',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> priceCurrency = GeneratedColumn<String>(
    'price_currency',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<int> precision = GeneratedColumn<int>(
    'precision',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<double> indexPrice = GeneratedColumn<double>(
    'index_price',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<double> userPrice = GeneratedColumn<double>(
    'user_price',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    $customConstraints: 'NULL',
  );
  late final GeneratedColumn<String> createdAt = GeneratedColumn<String>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    $customConstraints: 'NOT NULL',
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    fromCurrency,
    toCurrency,
    interval,
    marketPrice,
    price,
    priceCurrency,
    precision,
    indexPrice,
    userPrice,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'prices';
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {fromCurrency, toCurrency, interval, createdAt},
  ];
  @override
  PricesData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PricesData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      fromCurrency: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}from_currency'],
      )!,
      toCurrency: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}to_currency'],
      )!,
      interval: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}interval'],
      )!,
      marketPrice: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}market_price'],
      ),
      price: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price'],
      ),
      priceCurrency: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}price_currency'],
      ),
      precision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}precision'],
      ),
      indexPrice: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}index_price'],
      ),
      userPrice: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}user_price'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  Prices createAlias(String alias) {
    return Prices(attachedDatabase, alias);
  }

  @override
  List<String> get customConstraints => const [
    'UNIQUE(from_currency, to_currency, interval, created_at)',
  ];
  @override
  bool get dontWriteConstraints => true;
}

class PricesData extends DataClass implements Insertable<PricesData> {
  final int id;
  final String fromCurrency;
  final String toCurrency;
  final String interval;
  final double? marketPrice;
  final double? price;
  final String? priceCurrency;
  final int? precision;
  final double? indexPrice;
  final double? userPrice;
  final String createdAt;
  const PricesData({
    required this.id,
    required this.fromCurrency,
    required this.toCurrency,
    required this.interval,
    this.marketPrice,
    this.price,
    this.priceCurrency,
    this.precision,
    this.indexPrice,
    this.userPrice,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['from_currency'] = Variable<String>(fromCurrency);
    map['to_currency'] = Variable<String>(toCurrency);
    map['interval'] = Variable<String>(interval);
    if (!nullToAbsent || marketPrice != null) {
      map['market_price'] = Variable<double>(marketPrice);
    }
    if (!nullToAbsent || price != null) {
      map['price'] = Variable<double>(price);
    }
    if (!nullToAbsent || priceCurrency != null) {
      map['price_currency'] = Variable<String>(priceCurrency);
    }
    if (!nullToAbsent || precision != null) {
      map['precision'] = Variable<int>(precision);
    }
    if (!nullToAbsent || indexPrice != null) {
      map['index_price'] = Variable<double>(indexPrice);
    }
    if (!nullToAbsent || userPrice != null) {
      map['user_price'] = Variable<double>(userPrice);
    }
    map['created_at'] = Variable<String>(createdAt);
    return map;
  }

  PricesCompanion toCompanion(bool nullToAbsent) {
    return PricesCompanion(
      id: Value(id),
      fromCurrency: Value(fromCurrency),
      toCurrency: Value(toCurrency),
      interval: Value(interval),
      marketPrice: marketPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(marketPrice),
      price: price == null && nullToAbsent
          ? const Value.absent()
          : Value(price),
      priceCurrency: priceCurrency == null && nullToAbsent
          ? const Value.absent()
          : Value(priceCurrency),
      precision: precision == null && nullToAbsent
          ? const Value.absent()
          : Value(precision),
      indexPrice: indexPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(indexPrice),
      userPrice: userPrice == null && nullToAbsent
          ? const Value.absent()
          : Value(userPrice),
      createdAt: Value(createdAt),
    );
  }

  factory PricesData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PricesData(
      id: serializer.fromJson<int>(json['id']),
      fromCurrency: serializer.fromJson<String>(json['fromCurrency']),
      toCurrency: serializer.fromJson<String>(json['toCurrency']),
      interval: serializer.fromJson<String>(json['interval']),
      marketPrice: serializer.fromJson<double?>(json['marketPrice']),
      price: serializer.fromJson<double?>(json['price']),
      priceCurrency: serializer.fromJson<String?>(json['priceCurrency']),
      precision: serializer.fromJson<int?>(json['precision']),
      indexPrice: serializer.fromJson<double?>(json['indexPrice']),
      userPrice: serializer.fromJson<double?>(json['userPrice']),
      createdAt: serializer.fromJson<String>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'fromCurrency': serializer.toJson<String>(fromCurrency),
      'toCurrency': serializer.toJson<String>(toCurrency),
      'interval': serializer.toJson<String>(interval),
      'marketPrice': serializer.toJson<double?>(marketPrice),
      'price': serializer.toJson<double?>(price),
      'priceCurrency': serializer.toJson<String?>(priceCurrency),
      'precision': serializer.toJson<int?>(precision),
      'indexPrice': serializer.toJson<double?>(indexPrice),
      'userPrice': serializer.toJson<double?>(userPrice),
      'createdAt': serializer.toJson<String>(createdAt),
    };
  }

  PricesData copyWith({
    int? id,
    String? fromCurrency,
    String? toCurrency,
    String? interval,
    Value<double?> marketPrice = const Value.absent(),
    Value<double?> price = const Value.absent(),
    Value<String?> priceCurrency = const Value.absent(),
    Value<int?> precision = const Value.absent(),
    Value<double?> indexPrice = const Value.absent(),
    Value<double?> userPrice = const Value.absent(),
    String? createdAt,
  }) => PricesData(
    id: id ?? this.id,
    fromCurrency: fromCurrency ?? this.fromCurrency,
    toCurrency: toCurrency ?? this.toCurrency,
    interval: interval ?? this.interval,
    marketPrice: marketPrice.present ? marketPrice.value : this.marketPrice,
    price: price.present ? price.value : this.price,
    priceCurrency: priceCurrency.present
        ? priceCurrency.value
        : this.priceCurrency,
    precision: precision.present ? precision.value : this.precision,
    indexPrice: indexPrice.present ? indexPrice.value : this.indexPrice,
    userPrice: userPrice.present ? userPrice.value : this.userPrice,
    createdAt: createdAt ?? this.createdAt,
  );
  PricesData copyWithCompanion(PricesCompanion data) {
    return PricesData(
      id: data.id.present ? data.id.value : this.id,
      fromCurrency: data.fromCurrency.present
          ? data.fromCurrency.value
          : this.fromCurrency,
      toCurrency: data.toCurrency.present
          ? data.toCurrency.value
          : this.toCurrency,
      interval: data.interval.present ? data.interval.value : this.interval,
      marketPrice: data.marketPrice.present
          ? data.marketPrice.value
          : this.marketPrice,
      price: data.price.present ? data.price.value : this.price,
      priceCurrency: data.priceCurrency.present
          ? data.priceCurrency.value
          : this.priceCurrency,
      precision: data.precision.present ? data.precision.value : this.precision,
      indexPrice: data.indexPrice.present
          ? data.indexPrice.value
          : this.indexPrice,
      userPrice: data.userPrice.present ? data.userPrice.value : this.userPrice,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PricesData(')
          ..write('id: $id, ')
          ..write('fromCurrency: $fromCurrency, ')
          ..write('toCurrency: $toCurrency, ')
          ..write('interval: $interval, ')
          ..write('marketPrice: $marketPrice, ')
          ..write('price: $price, ')
          ..write('priceCurrency: $priceCurrency, ')
          ..write('precision: $precision, ')
          ..write('indexPrice: $indexPrice, ')
          ..write('userPrice: $userPrice, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    fromCurrency,
    toCurrency,
    interval,
    marketPrice,
    price,
    priceCurrency,
    precision,
    indexPrice,
    userPrice,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PricesData &&
          other.id == this.id &&
          other.fromCurrency == this.fromCurrency &&
          other.toCurrency == this.toCurrency &&
          other.interval == this.interval &&
          other.marketPrice == this.marketPrice &&
          other.price == this.price &&
          other.priceCurrency == this.priceCurrency &&
          other.precision == this.precision &&
          other.indexPrice == this.indexPrice &&
          other.userPrice == this.userPrice &&
          other.createdAt == this.createdAt);
}

class PricesCompanion extends UpdateCompanion<PricesData> {
  final Value<int> id;
  final Value<String> fromCurrency;
  final Value<String> toCurrency;
  final Value<String> interval;
  final Value<double?> marketPrice;
  final Value<double?> price;
  final Value<String?> priceCurrency;
  final Value<int?> precision;
  final Value<double?> indexPrice;
  final Value<double?> userPrice;
  final Value<String> createdAt;
  const PricesCompanion({
    this.id = const Value.absent(),
    this.fromCurrency = const Value.absent(),
    this.toCurrency = const Value.absent(),
    this.interval = const Value.absent(),
    this.marketPrice = const Value.absent(),
    this.price = const Value.absent(),
    this.priceCurrency = const Value.absent(),
    this.precision = const Value.absent(),
    this.indexPrice = const Value.absent(),
    this.userPrice = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  PricesCompanion.insert({
    this.id = const Value.absent(),
    required String fromCurrency,
    required String toCurrency,
    required String interval,
    this.marketPrice = const Value.absent(),
    this.price = const Value.absent(),
    this.priceCurrency = const Value.absent(),
    this.precision = const Value.absent(),
    this.indexPrice = const Value.absent(),
    this.userPrice = const Value.absent(),
    required String createdAt,
  }) : fromCurrency = Value(fromCurrency),
       toCurrency = Value(toCurrency),
       interval = Value(interval),
       createdAt = Value(createdAt);
  static Insertable<PricesData> custom({
    Expression<int>? id,
    Expression<String>? fromCurrency,
    Expression<String>? toCurrency,
    Expression<String>? interval,
    Expression<double>? marketPrice,
    Expression<double>? price,
    Expression<String>? priceCurrency,
    Expression<int>? precision,
    Expression<double>? indexPrice,
    Expression<double>? userPrice,
    Expression<String>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (fromCurrency != null) 'from_currency': fromCurrency,
      if (toCurrency != null) 'to_currency': toCurrency,
      if (interval != null) 'interval': interval,
      if (marketPrice != null) 'market_price': marketPrice,
      if (price != null) 'price': price,
      if (priceCurrency != null) 'price_currency': priceCurrency,
      if (precision != null) 'precision': precision,
      if (indexPrice != null) 'index_price': indexPrice,
      if (userPrice != null) 'user_price': userPrice,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  PricesCompanion copyWith({
    Value<int>? id,
    Value<String>? fromCurrency,
    Value<String>? toCurrency,
    Value<String>? interval,
    Value<double?>? marketPrice,
    Value<double?>? price,
    Value<String?>? priceCurrency,
    Value<int?>? precision,
    Value<double?>? indexPrice,
    Value<double?>? userPrice,
    Value<String>? createdAt,
  }) {
    return PricesCompanion(
      id: id ?? this.id,
      fromCurrency: fromCurrency ?? this.fromCurrency,
      toCurrency: toCurrency ?? this.toCurrency,
      interval: interval ?? this.interval,
      marketPrice: marketPrice ?? this.marketPrice,
      price: price ?? this.price,
      priceCurrency: priceCurrency ?? this.priceCurrency,
      precision: precision ?? this.precision,
      indexPrice: indexPrice ?? this.indexPrice,
      userPrice: userPrice ?? this.userPrice,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (fromCurrency.present) {
      map['from_currency'] = Variable<String>(fromCurrency.value);
    }
    if (toCurrency.present) {
      map['to_currency'] = Variable<String>(toCurrency.value);
    }
    if (interval.present) {
      map['interval'] = Variable<String>(interval.value);
    }
    if (marketPrice.present) {
      map['market_price'] = Variable<double>(marketPrice.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (priceCurrency.present) {
      map['price_currency'] = Variable<String>(priceCurrency.value);
    }
    if (precision.present) {
      map['precision'] = Variable<int>(precision.value);
    }
    if (indexPrice.present) {
      map['index_price'] = Variable<double>(indexPrice.value);
    }
    if (userPrice.present) {
      map['user_price'] = Variable<double>(userPrice.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<String>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PricesCompanion(')
          ..write('id: $id, ')
          ..write('fromCurrency: $fromCurrency, ')
          ..write('toCurrency: $toCurrency, ')
          ..write('interval: $interval, ')
          ..write('marketPrice: $marketPrice, ')
          ..write('price: $price, ')
          ..write('priceCurrency: $priceCurrency, ')
          ..write('precision: $precision, ')
          ..write('indexPrice: $indexPrice, ')
          ..write('userPrice: $userPrice, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class DatabaseAtV13 extends GeneratedDatabase {
  DatabaseAtV13(QueryExecutor e) : super(e);
  late final Transactions transactions = Transactions(this);
  late final WalletMetadatas walletMetadatas = WalletMetadatas(this);
  late final Labels labels = Labels(this);
  late final Settings settings = Settings(this);
  late final AppSettings appSettings = AppSettings(this);
  late final PayjoinSenders payjoinSenders = PayjoinSenders(this);
  late final PayjoinReceivers payjoinReceivers = PayjoinReceivers(this);
  late final ElectrumServers electrumServers = ElectrumServers(this);
  late final ElectrumSettings electrumSettings = ElectrumSettings(this);
  late final MempoolServers mempoolServers = MempoolServers(this);
  late final MempoolSettings mempoolSettings = MempoolSettings(this);
  late final Swaps swaps = Swaps(this);
  late final AutoSwap autoSwap = AutoSwap(this);
  late final Bip85Derivations bip85Derivations = Bip85Derivations(this);
  late final Recoverbull recoverbull = Recoverbull(this);
  late final Prices prices = Prices(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    transactions,
    walletMetadatas,
    labels,
    settings,
    appSettings,
    payjoinSenders,
    payjoinReceivers,
    electrumServers,
    electrumSettings,
    mempoolServers,
    mempoolSettings,
    swaps,
    autoSwap,
    bip85Derivations,
    recoverbull,
    prices,
  ];
  @override
  int get schemaVersion => 13;
  @override
  DriftDatabaseOptions get options =>
      const DriftDatabaseOptions(storeDateTimeAsText: true);
}
